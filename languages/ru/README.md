<a name="page-top"></a>

# Компендиум UMG-Slate

Локализовано с помощью [GitLocalize](https://gitlocalize.com/) (Пожалуйста, прочитайте страницу [ЧаВо](FAQ.md) о том, как стать переводчиком!)

<a name="document-version"></a>

###### Версия документа

<!---Major.Minor.Patch--->

*0.6.0*

<!---
Section naming:
Major.Minor.Mini

For creating diagrams I use lucidchart, it has a nice user interface and style for both creating charts and exporting(and it has a good free tier).

For the back to top arrow:
**[<span>&#11014;</span> Back to Top](#table-of-contents)**
Place this at the end of major sections and minor sections should only have it if its after 5+ mini sections for UX purposes.
Mini sections should only have it if its not the last section in the major and only on the last mini section.

UE5 Editor Background Color:
- Hex Linear: 040404FF
- Hex sRGB: 242424FF
- Value: 0.017642
- Red: 0.017642 OR 24.0
- Green: 0.017642 OR 24.0
- Blue: 0.017642 OR 24.0
- Alpha: 1.0

To add a fake indent, this adds a bunch of forced spaces(I hate this, would be nice to have a simple "&tab" or something):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

Some rules regarding linking table of contents information:
- "--" is used for symbols like %, $, #, @, &
- Adding a new main category requires you to update the numbers so for the link we don't include the number just to save needless effort

This document uses "split screen" and not "split-screen"(excluding HTML linkage) or "splitscreen".

For categories we don't include the words in parenthesis just to keep it short and reasonable.

HTML Notes:
- <tr></tr> This will end the line horizontally and start a new line vertically.
- <td></td> Will end the line vertically and start a new line horizontally.
- Use <i></i> To italicize text.
- Use <b></b> To bold text.
- <a href="LINK" target="_blank">DISPLAY TEXT</a> For links in HTML. `target="_blank"` will make a new tab/window when link is selected.
- <br> for line breaks.
- <ul><li></li></ul> for non-ordered lists.
- <ol><li></li></ol> for ordered numbered lists.

--->

<a name="repo-page-links"></a>

## Ссылки на страницы репозитория

> - [Страница часто задаваемых вопросов](FAQ.md)
> - [Страница внешних ссылок](EXTERNAL_LINKS.md)

<a name="table-of-contents"></a>

## Оглавление

> 1.0 [Введение](#introduction)<br>2.0 [Соображения касательно производительности и дизайна](#performance--design-considerations)<br>2.1 [Соображения касательно CPU](#cpu-considerations)<br>2.1.1 [Производительность в части анимаций](#cpu-considerations)<br>2.1.2 [Производительность в части Widget Components](#perf-widget-components)<br>2.2 [Соображения в части GPU](#gpu-considerations)<br>3.0 [Slate и UMG в Unreal](#perf-widget-components)<br>4.0 [Slate](#slate)<br>4.1 [Приведение типов (casting) и хранение виджетов Slate](#slate-widget-casting--storing)<br>4.2 [Slate Units и масштабирование DPI](#slate--umg-in-unreal)<br>4.3 [Slate Users](#slate-users)<br>4.4 [Макет виджета](#widget-layout)<br>4.5 [On Paint](#slate-widget-casting--storing)<br>4.6 [Widget Ticking](#widget-ticking)<br>4.7 [Иерархия виджетов](#widget-hierarchy)<br>4.8 [Инвалидация](#slate-users)<br>4.9 [Slate Attributes и Slate Events](#slate-attributes-and-events)<br>4.10 [Slate Widget Examples(Slate Test Suite/Starship Suite)](#slate-widget-examples)<br>4.11 [Полезные консольные команды для Slate](#on-paint)<br>5.0 [UMG (Unreal Motion Graphics)](#widget-ticking)<br>5.1 <a>Иерархия User Widgets</a><br>5.2 <a>Анимация User Widget</a><br>5.3 [User Widget Events](#invalidation)<br>6.0 <a>Common Widgets</a><br>7.0 <a>Функционал Common Widgets</a><br>8.0 [UMG в контексте миров (Levels)](#slate-widget-examples)<br>8.1 <a>HUD Actors</a><br>8.1.1 <a>Отрисовка HUD</a><br>8.1.2 [Хитбоксы HUD](#umg)<br>8.2 <a>Widget Components</a><br>8.2.1 <a>Widget Interaction Components</a><br>8.2.2 [Как Widget Components отрисовываются](#user-widget-animation)<br>9.0 <a>Инструменты разработки и отладки для UMG/Slate</a><br>9.1 <a>Отладочные команды консоли</a><br>9.2 [Widget Reflector](#common-widgets)<br>9.3 <a>Slate Console Debugger</a><br>10.0 [Input Framework в Unreal Engine (то, что связано с UMG/Slate)](#common-widget-functionality)<br>10.1 <a>Поток ввода (Input Flow) Unreal Engine</a><br>10.2 <a>Input Components</a><br>10.3 [Типы Input Event](#hud-actors)<br>10.4 <a>Input Modes</a><br>11.0 <a>Система фокусировки Unreal</a><br>11.1 [Объяснение навигационной сетки (Navigation Grid)](#hud-hitboxes)<br>11.2 <a>Navigation Genesis</a><br>12.0 <a>Split Screen</a><br>12.1 [Game Layer Manager](#widget-interaction-components)<br>12.2 <a>Viewport Layout</a><br>12.3 <a>Local Players</a><br>12.3.1 [Gamepad ID (Controller ID)](#dev-debug-tools)<br>13.0 <a>Имена важных файлов</a>

<a name="introduction"></a>

## 1.0 Введение

Этот компендиум предназначен для обучения основам UMG и Slate и для обеспечения базового понимания того, как работать с UI-фреймворком Unreal Engine. ПОЖАЛУЙСТА, дайте мне знать, если есть что-то в этом документе, что можно улучшить, потому что это предназначено для помощи сообществу!

Пожалуйста, обратитесь к [странице ЧаВо](FAQ.md) (на которую ещё есть ссылка вверху документа), если у вас есть дополнительные вопросы относительно документа (или чего-либо, связанного с документом).

> Важное замечание об уровне навыков в программировании и о том, как он используется в этом документе: обычно, когда кто-то называет концепцию *"высокоуровневой"*, имеется в виду, что она очень сложная и требует высокого уровня навыков или большого опыта, **НО** в программировании это перевернуто; там *"высокоуровневая"* концепция на самом деле чрезвычайно проста в использовании и представляет собой простую концепцию, которая требует мало или вообще не требует опыта, и чем более *"низким"* становится уровень, тем более сложной становится концепция, и требуется больше опыта. Например; **Blueprint** — это язык программирования *"высокого уровня"*, **C++** — язык программирования *"низкого уровня"* .
>
> У GeeksForGeeks есть отличная и простая статья, объясняющая разницу:<br> *<u>https://www.geeksforgeeks.org/difference-between-high-level-and-low-level-languages/</u>*

> Важное примечание о двух типах Unreal Engine:
>
> - **Версия из Лаунчера**: версия движка, которую вы загружаете из лаунчера Epic Games; движок доступен для просмотра, но не может быть изменен и не может отправлять изменения кода в Epic через GitHub.
> - **Версия из исходников**: Версия движка, которую вы клонируете/скачиваете с GitHub; она дает полный доступ к Unreal Engine с возможностью модификации, а также возможность отправлять изменения кода в Epic через GitHub Pull Request'ы для интеграции в будущие релизы Unreal Engine.

*Все изображения редактора в этом документе взяты из лаунчерной версии.*

О чем этот компендиум:

- **Вопросы производительности и дизайна**
- **Фреймворк Slate**
- **Фреймворк UMG**
- **Фреймфорк ввода Unreal Engine (относится к UMG/Slate)**
- **Как работает встроенная система фокусировки**
- **Как обычно работает режим разделенного экрана**

Он **НЕ** предназначен для того, чтобы научить новичков использовать Unreal Engine в целом, а только понять этот конкретный аспект движка, который охватывает большую часть движка.

Этот сборник требует от вас базового понимания следующих областей Unreal Engine:

- **Как использовать Blueprint и Unreal C++**
- **Структура сборщика мусора Unreal Engine**
- **Фреймворк геймплея Unreal Engine**

Этот сборник будет содержать информацию, взятую из официальной документации, но предназначен для того, чтобы пролить свет на то, что означает часть официальной документации, НО это не переопределение того, что уже объяснено.

*В нижней части документа находится список полезных ссылок и файлов, к которым вы можете вернуться <br> (их можно легко найти с помощью ссылки [Страница внешних ссылок](EXTERNAL_LINKS.md) в верхней части файла).*

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="performance--design-considerations"></a>

## 2.0 Соображения касательно производительности и дизайна

[Официальная документация Epic по производительности и рекомендациям по оптимизации для Slate и UMG](https://docs.unrealengine.com/latest/INT/optimization-guidelines-for-umg-in-unreal-engine/)

**UMG** и **Slate** — чрезвычайно производительные платформы как для рендеринга (GPU), так и для вычислений (CPU). Но оба аспекта следует учитывать при создании пользовательского интерфейса, чтобы обеспечить наилучшее взаимодействие с пользователем.

> Это не руководство «как повысить производительность», это соображения, которые следует учитывать при создании приложения с помощью UMG/Slate, а также возможные способы повышения производительности.

Сложность UI (пользовательского интерфейса) обычно связана с количеством активных и видимых виджетов (поэтому виджеты за пределами экрана не отмечаются и не должны запускать функции, если они не на экране). Обычный технический дизайн пользовательского интерфейса должен реагировать на код игрового процесса (это также предлагается, если ваша игра не зависит от UI), но не управлять кодом игрового процесса, чтобы он был производительным и пригодным для повторного использования; часто нормально для UI быть отправной точкой для выполнения геймплейного кода, но тогда он должен "слушать", как отвечает геймплейный код, и реагировать на это.

<a name="cpu-considerations"></a>

### 2.1 Соображения касательно CPU

Slate/UMG используют концепцию [инвалидации](#invalidation) и кэширования, а не постоянно опрашивают данные. Причина этого в том, что иногда опрос либо неэффективен, либо функционально неверен (например, при использовании многопоточного кода). Обычно производительный пользовательский интерфейс в Unreal должен быть **основан на событиях (Events)**. В UMG есть **Property Binds**, но их не следует использовать, поскольку они будут обновляться в каждом кадре, что значительно увеличивает нагрузку на ЦП, чем использование архитектуры, основанной на событиях (event-based).

**Сценарий технического проектирования ЦП**
:-:
В RTS вам нужен маркер пользовательского интерфейса, чтобы видеть, где разместить отряд солдат в мире,<br> игрок выбирает подходящее место в мире для размещения маркера пользовательского интерфейса, а затем войска будут двигаться к нему.

**Хороший пример** | **Плохой пример**
:-: | :-:
Объект менеджера игрока создает UI-виджет маркера и управляет тем, куда перемещать войска.<br> Позиция в мире, выбранная игроком, передается в UI-виджет маркера (из объекта менеджера игрока), а сам виджет обрабатывает свое позиционирование на экране. | Игрок выбирает позицию в мире и передает ее непосредственно UI-маркеру, затем UI-маркер напрямую сообщает войскам, куда двигаться, и обрабатывает их движение.

<a name="perf-animations"></a>

#### 2.1.1 Производительность в части анимаций

Инвалидация desired size нескольких виджетов при анимации большого количества виджетов может иметь последующие последствия, связанные с затратой большого количества процессорного времени на повторный расчет [Widget Layout](#widget-layout).

- В предыдущих версиях Unreal Engine при проигрывании анимации с виджетом UMG, те существовали отдельно от Sequencer (после релиза Sequencer это быстро обновили, чтобы Sequencer использовался в качестве базовой системы анимации).
- В предыдущих версиях Unreal Engine после обновления Sequencer виджет UMG при анимации становился volatile.
- В текущих версиях Unreal Engine виджеты UMG не переключаются на volatile при анимации.

Почему я должен использовать volatile?

> Честно говоря, это не всегда однозначно понятно, что происходит, когда вы анимируете виджет UMG или меняете его визуальное состояние, это инвалидирует виджет для этого кадра и повторно кэширует его новое состояние, пока оно не будет снова невалидным позже. Установка его на volatile не инвалидирует и не кэширует виджет, тот проходит через отдельную ветку кода для volatile виджетов, что в каждом конкретном случае является основой для повышения производительности. Некоторые способы использования volatile — это включить его на определенный период времени, а затем отключить, когда он вам больше не нужен.

- Некоторые напоминания об использовании volatile:
    - Он не кэширует состояние виджета, он опрашивается каждый кадр, когда он находится на экране.
    - Он склонен влиять на иерархию виджетов, поэтому помните о последующих эффектах для родительских виджетов И дочерних виджетов тоже.

<a name="perf-widget-components"></a>

#### 2.1.2 Производительность в части Widget Components

Widget Components отлично подходят для создания прототипов и для интерфейса AR/VR. Они не очень хороши, когда вы хотите сделать так, чтобы UI находился прямо в мире, при этом учитывая размер экрана, логику управления макетом и т.д.<br> Обычно хорошо использовать WIdget Components, если это позволяет ваш texture budget, потому что каждый компонент виджета на самом деле представляет собой static mesh plane с render target-текстурой, примененной к нулевому слоту материала.<br> Каждый widget component создаст объект UMG widget, а затем отрендерит его в текстуру, чтобы отобразить в мире.

Не рекомендуется активно использовать Widget Components (за исключением VR/AR) из-за использования памяти для текстур. Альтернативой (более сложной) является создание пользовательского Slate Widget для одновременной обработки нескольких "виджетов". Вы можете сделать это с помощью `SMeshWidget`, который представляет собой 1 draw call для каждого виджета, но для этого требуются соответствующие навыки в technical art, чтобы иметь возможность рисовать несколько элементов виджетов как 1 текстуру.

Что такое `SMeshWidget`?<br> Это виджет, который имеет возможность рисоваться за 1 draw call, он использовался в Paragon для отрисовки каждого status bar и иконки на экране. Он чрезвычайно мощный, но также требует хорошего понимания того, как рисовать эти элементы в коде, вот почему вы не видите, что он часто используется, он предназначен не только для текстур или частиц, но может использоваться с 3D-моделями/мешами и всем, что вы хотите визуализировать.

Ник Дарнелл собрал пример использования `SMeshWidget` для отрисовки частиц в UE4:

- [Ссылка на форум](https://forums.unrealengine.com/t/smeshwidget-hardware-instanced-slate-meshes-thread/58020/5)
- [Дэн Требл любезно превратил пример проекта в Github-репозиторий.](https://github.com/dantreble/MeshWidgetExample)

Кэри Хиклинг выступила на Unreal Fest с докладом «Оптимизация и создание UI для AAA-игр» и рассказала о плюсах и минусах `SMeshWidget`: [ссылка на YouTube](https://youtu.be/OyY3OYbNK7s)

В качестве другого возможного пути рекомендуем взглянуть на пример проекта Epic Lyra и на систему индикаторов, связанные файлы в этом проекте:

- `SActorCanvas`.h/.cpp
- `IndicatorLayer`.h/.cpp
- `IActorIndicatorWidget`.h/.cpp
- `IndicatorDescription`.h/.cpp
- `IndicatorLibrary`.h./cpp
- `LyraIndicatorManagerComponent`.h/.cpp

<a name="gpu-considerations"></a>

### 2.2 Соображения в части GPU

Большинство общих соображений относительно GPU, о которых вам придется беспокоиться, те же, что и при работе в сфере 3D, например:

- **Размер памяти текстур**
- **Вычислительная сложность шейдера материала**
- **Draw calls**

Если ваша архитектура построена правильно, оптимизация графического процессора не будет проблемой, когда дело доходит до Slate/UMG, поскольку он использует некоторые функции 3D-рендеринга Unreal для унификации части работы.

Важный момент с Unreal Engine заключается в том, что у него нет надежного метода переключения между различными текстурами в зависимости от типа платформы.<br> Например; при переходе с мобильных устройств на ПК вам придется создавать эти системы самостоятельно, чтобы неиспользуемые текстуры не готовились, не загружались,<br> не линкованись и даже не хранились на жестком диске на платформе, на которой вы не хотите, чтобы они находились.

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="slate--umg-in-unreal"></a>

## 3.0 Slate и UMG в Unreal

Unreal Engine использует **Slate**; его собственный **фреймворк для программирования UI**. Он используется как для игровых, так и для неигровых приложений, использующих Slate Widgets.<br> Вот некоторые примеры:

- Unreal Editor полностью построен с использованием Slate.
- (Спасибо Нику Дарнеллу за объяснение этого) Epic Games Launcher использует Slate в качестве рамки и отображает приложение Chromium.
- Коллекция Halo Master Chief использует UMG/Slate (нужно уточнить) для своего пользовательского интерфейса (это основано на публичных объявлениях, а не на инсайдерских знаниях).

**Slate** полностью используется только в C++ с использованием декларативного синтаксиса и **<u>НЕ</u>** наследуется от `UObject`.

Плюсы Slate:

- **Повышение производительности за счет полной реализации на C++**
- **Может использоваться для обычных приложений** (примером этого является то, что программа запуска Epic Game и сам Unreal Editor полностью построены на Slate)
- **Используется для расширения редактора** (в первую очередь это связано с тем, что Unreal Editor построен на Slate)
- **Не работает с системой сборщика мусора движка**

Минусы Slate:

- **Сделан целиком на C++** (нет визуального дизайнера, для этого действительно нужен UMG Designer)
- **У него не может быть Sequencer-анимаций** (все хардкодится, поэтому время итерации увеличивается)
- **Требует глубоких знаний, чтобы иметь возможность использовать его для полноценного продакшена**
- **Невозможно использовать с Blueprints**
- **Не используется Reflection-системой движка, значит, не работает с системой сборщика мусора движка**

![Пример галереи звездолета](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/starship_gallery.png?raw=true)<br> *Slate Test Suite (в UE5 он называется Starship Gallery)*

**UMG** (**Unreal Motion Graphics**) наследуется от `UObject`, но не является `Actor` и используется для создания и отображения виджетов Slate (по сути, дружественная к Unreal Engine обёртка вокруг Slate для работы с Blueprint).

Плюсы UMG:

- **Может использоваться в Blueprints и C++**
- **Позволяет создавать анимацию силами художников**
- **Есть визуальный дизайнер**
- **Используется с системой рефлексии Unreal, значит, работает с системой сбора мусора движка.**
- **Возможность расширения редактора** (Unreal Engine 4.23+ с помощью Editor Utility Widgets)

Минусы UMG:

- **Только для Unreal Engine** (не может использоваться вне движка для обычных приложений в ОС)
- **Простота использования означает для разработчиков возможность увеличения технического долга, а UI возможность стать запутанным.**

![Пример дизайнера UMG](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/umg_designer.png?raw=true)

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="slate"></a>

## 4.0 Slate

Slate Framework состоит из двух основных частей:

- **Slate Renderer**
    - Slate Widgets отображаются с использованием собственного отрисовщика, называемого Slate Renderer. Он обрабатывает элементы пользовательского интерфейса перед игровым viewport, а также объединяется с пайплайном рендеринга мира Unreal для отображения элементов UI.
- **Slate Application**
    - Slate Application — это объект, который управляет всеми задачами виджетов Slate, связанными с CPU, такими как их позиции во viewport, навигация по фокусу пользователя, размещение и отслеживание иерархии виджетов, получение ввода и направление этого ввода либо в Slate Widgets, либо в остальную часть игрового движка (да, это то место, где необработанные данные ввода принимаются до того, как их получит элемент UI) и регистрация (создание)/отслеживание Slate Users.

<a name="slate-widget-casting--storing"></a>

### 4.1 Приведение типов (casting) и хранение виджетов Slate

Поскольку **виджеты Slate** **<u>НЕ</u>** наследуются от `UObject`, это означает, что вы не можете использовать систему приведения объектов Unreal для получения определенных типов Slate, а также не можете воспользоваться сборщиком мусора `UObject`. Вместо этого Slate использует платформу Unreal Shared Pointers (также известную как Smart Pointers) для управления памятью Widgets.

Существует три типа шаблонов shared poiner:

- `TSharedRef`: необнуляемый, считающий ссылки, ненавязчивый (non-intrusive) авторитетный умный указатель.
- `TSharedPtr`: ненавязчивый (non-intrusive) авторитетный интеллектуальный указатель с подсчетом ссылок.
- `TWeakPtr`: считающая ссылки, ненавязчивая (non-intrusive) ссылка на слабый указатель.

> Важно уточнить момент, когда все счетчики ссылок для общей(shared) ссылки исчезли; объект будет удален, и ограничение состоит в том, что он будет вызывать только деструктор по умолчанию, поэтому пользовательские деструкторы с параметрами использовать нельзя.

Использование shared pointers позволяет вам стать владельцем этих slate widgets без необходимости вызывать для них удаление.<br> *Я рекомендую взглянуть на [документацию Epic по Smart Pointers.](https://docs.unrealengine.com/5.0/en-US/smart-pointers-in-unreal-engine/)*

> Важно отметить, что при приведении типов (casting) Slate Widget совершенно нормально использовать стандартное приведение, такое как `static_cast` и `const_cast`, но я рекомендую использовать анриловские шаблонные версии приведения, перечисленные ниже, чтобы сэкономить время.

Существуют также вспомогательные классы и функции, облегчающие жизнь при использовании инфраструктуры анриловских shared pointers, включая работу со Slate.

- `MakeShareable`: используется для инициализации общих указателей из указателей C++.
    ```c++
    TSharedPtr<FMyCustomCalculator> calculator = MakeShareable(new FMyCustomCalculator());
    ```
- `TSharedFromThis`: используется с пользовательскими классами C++ как то, от чего вы наследуете, чтобы его можно было использовать с инфраструктурой анриловских shared pointers.
    ```c++
    /** Специальный класс для обработки собственных расчётов */
    class FMyCustomCalculator : public TSharedFromThis<FMyCustomCalculator>
    {
    public:
      FMyCustomCalculator()
      { }
      // ...
    };
    ```
- `StaticCastSharedRef`: служебная функция для static cast, обычно используемая для приведения к производному типу при получении умной ссылки.
    ```c++
    void MyFunction(FMySubCalculator& CalculatorItem)
    {
      TWeakPtr<FMyCustomCalculator> calculator = StaticCastSharedRef<FMyCustomCalculator>(CalculatorItem.AsShared());
      // ...
    }
    ```
- `ConstCastSharedRef`: преобразует `const` ссылку в `mutable` умную ссылку.
    ```c++
    void MyFunction(TSharedRef<const FMyCustomCalculator> CalculatorItem)
    {
      TSharedRef<FMyCustomCalculator> calculator = ConstCastSharedRef<FMyCustomCalculator>(CalculatorItem);
      // ...
    }
    ```
- `StaticCastSharedPtr`: служебная функция для dynamic cast, обычно используемая для приведения к производному типу. Это то, что вы могли бы использовать вместо `static_cast` (необязательно, но так короче).
    ```c++
    void MyFunction(TWeakPtr<FMyCustomCalculator> CalculatorItem)
    {
      TSharedPtr<FMyCustomCalculator> calculator = StaticCastSharedPtr<FMyCustomCalculator>(CalculatorItem.Pin());
      // ...
    }
    ```
- `ConstCastSharedPtr`: преобразует `const` умный указатель в `mutable` умный указатель. Это то, что вы могли бы использовать вместо `const_cast<>` (необязательно, но так короче).
    ```c++
    void MyFunction(TSharedPtr<const FMyCustomCalculator> CalculatorItem)
    {
      TWeakPtr<FMyCustomCalculator> calculator = ConstCastSharedPtr<FMyCustomCalculator>(CalculatorItem);
      // ...
    }
    ```

Для получения дополнительной информации обратитесь к этим файлам:

- Примеры использования различных служебных функций и шаблонов: `Engine/Source/Runtime/Core/Public/Templates/SharedPointerTesting.inl`
- Объяснение системы общих указателей Unreal Engine: `Engine/Source/Runtime/Core/Public/Templates/SharedPointer.h`

<a name="slate-units--dpi-scaling"></a>

### 4.2 Slate Units и масштабирование DPI

- **Slate Units**: способ Unreal создать UI, который не зависит от плотности пикселей, поэтому ваше приложение может легко поддерживать несколько платформ. Это позволяет сделать его более точным и независимым от плотности пикселей на мониторе пользователя. Отдельный slate unit может различаться по физическому размеру, но по умолчанию удобно установить его на 1 пиксель для каждого slate unit. Чтобы установить значение по умолчанию, вместо этого рекомендуется настроить базовое масштабирование DPI.
- **Масштабирование DPI**: то, как Unreal регулирует преобразование slate units в рантайме, масштабируя каждый slate unit на это значение, например, если ваши slate units установлены на 1 единицу = 1 пикселю, а масштабирование dpi установлено на значение 2,5, тогда каждый slate unit будет равен 1 единице = 2,5 пикселям. Вы можете изменить масштабирование DPI в зависимости от разрешения с помощью curve table в Project Settings в категории "Engine - User Interface".

Сами Epic признают, что он не идеален, но он хорошо работает для большинства кейсов.<br> [Эпиковский AnswerHub с объяснением Slate Units](https://forums.unrealengine.com/t/what-are-slate-units/310703)

<a name="slate-users"></a>

### 4.3 Slate Users

**Slate Users** — это классы, которые представляют собой отдельного локального пользователя, осуществляющего ввод (например, в совместной игре с 3 игроками в split screen есть 3 Slate Users, а в онлайн-игре с 32 игроками и без split screen — только один Slate User). **SDK каждой платформы** сообщит **Slate Application** о необходимости зарегистрировать (создать) нового Slate User при добавлении нового подключения (например, при подключении нового контроллера). При добавлении нового подключения создается новый Slate User, но не при удалении подключения из-за случайного отключения контроллера (чтобы сохранить настройки для этого контроллера на случай повторного подключения). Когда соединение удаляется, этот Slate User просто не обновляется. Экземпляр Slate User отслеживает виджет, на котором в данный момент находится фокус пользователя, и управляет курсором/имеет информацию об указателе для учета жестов (это только для первого пользователя Slate, поскольку вы не можете подключить несколько мышей, а если вы подключили, то... зачем?).

Вы можете получить доступ к Slate User двумя основными способами:

- Из Slate Application с использованием целочисленного индекса для этого локального Slate User.
- Из объекта `ULocalPlayer`, который вы можете получить из любого Player Controller.

> Важно отметить, что Local Player может существовать до того, как будет создан Player Controller (в Player Controllers есть функции для случаев, когда их Local Player установлен, которые вы можете переопределить), а Local Player существует между уровнями, а не на каждом уровне, как Player Controllers, поскольку они UObjects, а не Actors.

```c++
// Вот как можно получить local player в зависимости от ваших нужд
// Предполагается, что это пример,
// НЕ ДЛЯ ФИНАЛЬНОГО/РЕЛИЗНОГО КОДА
ULocalPlayer* localPlayer = nullptr;
if(UWorld* const world = GetWorld())
{
    if(APlayerController* const pc = world->GetFirstPlayerController())
    {
        localPlayer = pc->GetLocalPlayer();
    }
}
// Проверка указателя на local player на валидность
if(!IsValid(localPlayer))
{
    // Если невалидный, то выйти из функции
    return;
}
// Проверить, что Slate инициализирован и корректно работает
if(FSlateApplication::IsInitialized())
{
    // Функция вернёт Slate User, к которому привязан local player
    FSlateApplication::Get().GetUser(localPlayer->GetControllerId());
}
```

*Пример кода, как получить Slate User с помощью local player от player controller*

<a name="widget-layout"></a>

### 4.4 Макет виджета

Способ расчета макета Slate Widgets выполняется в два прохода (перечислены в порядке выполнения):

1. **Cache Desired Size**: подсчитывание того, сколько места каждый виджет должен занимать, это происходит с помощью подхода *"снизу вверх"*, когда гарантируется, что когда этот проход происходит для виджета, его дочерние элементы уже вычислили и кэшировали desired size.

![Пример кэширования desired size](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/cache_desired_size.png?raw=true)<br> *Пример желаемого размера Horizontal Box с текстовым блоком и виджетом Image*

Для примера желаемого размера у нас есть Horizontal Box, содержащий Text Block и виджет Image. В этом случае мы вычисляем желаемый размер Text Block (который измеряется отображаемой строкой) и виджета Image (который измеряется на основе отображаемых данных изображения). Затем Horizontal Box вычисляется путем объединения желаемых размеров Text Block и виджета Image (мы предполагаем, что Text Block занимает 14 Slate Units, а виджет Image — 8 Slate Units), поэтому для этого примера 14 Slate Units + 8 Slate Units = 22 Slate Units.

1. **Arrange Children**: это происходит в подходе *"сверху-вниз"*, когда виджет просят упорядочить свои дочерние элементы на основе их желаемых размеров и желаемого размера самого виджета (все это получили при первом проходе).

![Пример кэширования desired size](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/arrange_children.png?raw=true)<br> *Пример желаемого размера Horizontal Box с текстовым блоком и виджетом Image*

В примере с упорядоченными дочерними элементами горизонтальному блоку было выделено 25 единиц планшета родительским виджетом (не показано для простоты). Первый слот горизонтальной рамки указывает, что ему нужен желаемый размер дочернего элемента, который составляет 14 единиц планшета от текстового блока, в то время как второй слот хочет заполнить доступную ширину, которая составляет 11 единиц планшета, оставшихся для виджета изображения.

<a name="on-paint"></a>

### 4.5 On Paint

**Drawing Slate** — это процесс, в котором Slate перебирает все видимые виджеты и создает список **Draw Elements** для отправки в систему рендеринга, этот список создается каждый кадр.

Это происходит в функции On Paint, которая делает две вещи:

- Располагает все дочерние элементы на основе их **геометрии** (желаемого размера).
- Рисует реальную графику, связанную с этим виджетом.

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="widget-ticking"></a>

### 4.6 WIdget Ticking

Сами Slate Widgets (а значит, и UMG Widgets) не имеют тиков (как такты процессора или ticks), у них нет Tick Components и нет tick groups. Порядок тиков Slate Widget происходит во время прохода Paint, при этом эти вызовы исходят из Slate Application, поэтому функция Tick виджета будет вызываться только тогда, когда он отображается на экране и рендерится:

1. `FSlateApplication::Tick`
2. `FSlateApplication::TickAndDrawWidgets` ...
3. `SWidget::Paint`
4. `SWidget::OnPaint` ...
5. `SObjectWidget::Tick`
6. `UUserWidget::NativeTick` (это когда Blueprint тоже получит тик)

<a name="widget-hierarchy"></a>

### 4.7 Иерархия виджетов

Концепция **иерархии виджетов (Widget Hierarchy)** реализована с использованием дочерних слотов (child slots), которые являются необязательными объектами, которые могут быть привязаны к Slate Widget (поскольку у некоторых виджетов не может быть дочерних элементов, как у виджета Image (**Leaf WIdget**, как лист дерева иерархии)), но требуют, чтобы слот был собственной конструкцией, отслеживающей все дочерние виджеты, например, как  у виджета Button (составного виджета или **Compound Widget**) может быть только 1 дочерний виджет, в то время как у виджета Overlay может быть несколько дочерних виджетов.

Виджеты обычно бывают трех основных типов:

-  **Leaf Widgets**: виджеты без дочерних слотов. <br>![Пример Leaf Widgets](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/leaf_widgets.png?raw=true)
-  **Panel Widgets**: с динамическим количеством дочерних слотов. <br>![Пример Panel Widgets](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/panel_widgets.png?raw=true)
-  **Compound WIdgets**: виджеты с фиксированным количеством явно названных дочерних слотов. <br>![Пример Compound Widgets](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/compound_widgets.png?raw=true)

Ключевые элементы любого Slate Widget (также известного как SWidget, где каждый Slate WIdget начинается с заглавной буквы «S» в C++) представляет собой сочетание функций и значений:

- **Compute Desired Size** (Функция): отвечает за вычисление желаемого размера в качестве первого прохода для расположения элементов.
    - **Slate Rect** (Значение): прямоугольник с началом в верхнем левом углу, определяемый левым верхним и правым нижним углами. Исходная точка находится в верхнем левом углу, ось Y идет вниз, а ось X идет вправо. Это используется при расчёте желаемого размера и границ.
- **Arrange Children** (Функция): отвечает за размещение дочерних виджетов в качестве второго прохода для расположения элементов.
- **On Paint** (Функция): отвечает за реальный внешний вид виджета.
- **Event Handlers** (делегаты значений и/или функций): это хуки на основе событий для элементов UI, которые изменяются во время выполнения, обычно в форме "OnЧтоНибудь".

<a name="invalidation"></a>

### 4.8 Инвалидация

[Официальная документация Epic про инвалидацию в Slate и UMG](https://docs.unrealengine.com/latest/INT/invalidation-in-slate-and-umg-for-unreal-engine/)

Чтобы избежать необходимости вычислять желаемый размер виджета в каждом кадре (что может нагружать CPU, если это происходит с большим количеством виджетов одновременно), у виджетов есть концепция кэширования их желаемого размера, но во время выполнения, если размер виджета меняется (либо через анимацию, либо через игровой код), то он **инвалидирует** виджет, чтобы сообщить Slate, что этот виджет должен пересчитать его желаемый размер (**Desired Size**), а затем рассчитать заново расположение виджетов (**Rearrange the Layout**). Это оптимизация, позволяющая избежать опроса желаемого размера каждого виджета в каждом кадре, когда нет необходимости его пересчитывать.

Существуют различные типы причин инвалидации, которые вы можете указать при инвалидации виджета, они расположены в `InvalidateWidgetReason.h`:

- Layout: используйте инвалидацию Layout, если ваш виджет должен изменить желаемый размер. Это дорогостоящая инвалидация, поэтому не используйте ей, если все, что вам нужно сделать, это перерисовать виджет.
- Paint: Используйте, когда отрисовка виджета была изменена, но ничто не повлияло на размер виджета.
- Volatility: используйте, если была скорректирована только volatility виджета.
- ChildOrder: дочерний элемент был добавлен или удален (подразумевается Prepass и Layout).
- RenderTransform: изменен Render Transform виджетов.
- Visibility: изменение видимости (подразумевается Layout).
- AttributeRegistration: Атрибуты привязаны или отвязаны (эту причину использует SlateAttributeMetaData).
- Prepass: рекурсивно перекэшировать желаемый размер всех дочерних элементов этого виджета (подразумевается Layout).
- PaintAndVolatility: используйте инвалидацию Paint, если вы изменяете обычное свойство, связанное с рисованием или изменением размера. Дополнительно, если измененное свойство каким-либо образом влияет на Volatility, важно использовать инвалидацию volatility, чтобы ее можно было пересчитать и кэшировать.
- LayoutAndVolatility: используйте инвалидацию Layout, если вы изменяете обычное свойство, связанное с рисованием или изменением размера. Дополнительно, если измененное свойство каким-либо образом влияет на Volatility, важно использовать инвалидацию volatility, чтобы ее можно было пересчитать и кэшировать.

<a name="slate-attributes-events"></a>

### 4.9 Slate Attributes и Slate Events

Slate (и через Slate, UMG) поддерживает использование атрибутов для привязки свойств/функций/лямбд к свойствам виджета. Атрибуты виджета обновляются только в том случае, если виджет visible/не collapsed, поэтому установка его видимости в hidden приведет к тому, что они не будут обновляться.

Атрибуты особенно полезны при стилизации виджетов, когда вы можете указать различные визуальные стили виджетов по всему проекту как общую тему. Это повышает производительность в рамках проекта как для инженерных, так и для артовых команд.

- `TAttribute`: Базовый тип атрибута Unreal Engine, не используйте для свойств-членов в SWidget'ах.
    - Не совместим с инвалидацией, так как не делает broadcast при изменении.
    - Не cache-friendly (то есть может быть медленнее для процессора).
    - Если вы используете `TAttribute` для изменения состояния SWidget, то вам необходимо переопределить `ComputeVolatility` (это не требуется для `TSlateAttribute` и `TSlateManagedAttribute`).
- `TSlateAttribute`: Должен использоваться со свойствами-членами SWidget, позволяет свойству работать с системой аннулирования Slate и является более производительным для кода, специфичного для Slate, сохраняя безопасность атрибутов во всем движке.
    - Не наследуется от `TAttribute`, а наследуется от `FSlateAttributeBase`/`TSlateMemberAttribute`.
    - Не копируемый, но если вам нужно, чтобы он был movable, то рекомендуется использовать `TSlateManagedAttribute` вместо него.
    - Обновляются один раз за кадр в фазе обновления PrePass и благодаря этому более производительны.
    - Member attributes обновляются в том порядке, в котором переменные определены в определении SWidget (по умолчанию).
    - Позволяет сделать invalidation reason предикатом и/или может быть переопределён для каждого SWidget, но используйте это с осторожностью, так как это может нарушить invalidation для родительских виджетов.
- `TSlateManagedAttribute`: Должен использоваться с member properties SWidget, которые находятся внутри массивов ИЛИ других подвижных структур данных.
    - Не наследуется от `TAttribute`, а наследуется от `FSlateAttributeBase`/`TSlateMemberAttribute`.
    - Их можно только перемещать, но не копировать, из-за этого они потребляют больше памяти.

> - `TAttributes` имеют большие накладные расходы памяти и не cache-friendly. Поэтому используйте их по своему усмотрению.
> - Все атрибуты Slate сохраняются внутри `SlateAttributeMetaData` для легкого доступа в каждом SWidget.

При объявлении макросов событий и атрибутов внутри SWidget необходимо, чтобы они находились между двумя другими макросами:

- `SLATE_BEGIN_ARGS` ИЛИ `SLATE_USER_ARGS`: Разница в том, что `SLATE_USER_ARGS` требует, чтобы у пользователя вся реализация виджета находилась в исходном файле, поэтому заголовок может содержать только информацию о декларации, где все обработчики, по сути, являются действительно приватными и могут быть inlined (так что меньше boilerplate кода).
- `SLATE_END_ARGS`

Использование этих макросов позволяет авторам виджетов добавить поддержку конструирования виджетов через `SNew` и `SAssignNew`.

У атрибутов в Slate также есть специальные макросы, которые должны быть использованы при их объявлении и должны быть использованы, если вы хотите раскрыть эти свойства при создании виджета Slate в рантайме.

- `SLATE_ATTRIBUTE`:
    - Позволяет использовать атрибут со значением ИЛИ функцией.
    - Принимает тип атрибута в качестве первого параметра и имя атрибута в качестве второго параметра (желательно, чтобы совпадало с member property, чтобы избежать путаницы).
- `SLATE_ARGUMENT`:
    - Позволяет использовать атрибут только со значением.
    - Принимает тип атрибута в качестве первого параметра и имя атрибута в качестве второго параметра (желательно, чтобы совпадало с member property, чтобы избежать путаницы).
- `SLATE_ARGUMENT_DEFAULT`: То же самое, что и `SLATE_ARGUMENT`, но также поддерживает значения по умолчанию, синтаксис: `SLATE_ARGUMENT_DEFAULT(float, WheelScrollMultiplier) = 1.0f;`
- `SLATE_STYLE_ARGUMENT`: То же самое, что и `SLATE_ARGUMENT`, но они могут использоваться только с типами, которые наследуются от `FSlateWidgetStyle` для визуальной стилизации виджета.

Вот пример, в котором мы создаем пользовательский виджет кнопки, используя эти макросы.

```c++
class SMyButtonWidget : public SMyParentWidget
{
    SLATE_DECLARE_WIDGET(SMyButtonWidget, SMyParentWidget)
public:

    /** Setup default values for these arguments, underscore is to avoid shadowing of member names */
    SLATE_BEGIN_ARGS( SMyButtonWidget )
        : _Style(&FCoreStyle::Get().GetWidgetStyle< FButtonStyle >( "Button" ))
        , _AdditionalPadding(FMargine(4.0f, 2.0f))
        , _CanBounce(true)
    { }

    /** Scaling for after the button is customized */
    SLATE_ARGUMENT_DEFAULT( float, CustomizedScaling ) = 1.0f;

    /** Visual style of the button */
    SLATE_STYLE_ARGUMENT( FButtonStyle, Style )
    
    /** Additional padding for what this button needs to display its visuals. */
    SLATE_ATTRIBUTE( FMargin, AdditionalPadding )
    
    /** For knowing if the button should be able to bounce when clicked. */
    SLATE_ARGUMENT( bool, CanBounce )

    SLATE_END_ARGS()
    
    /**
	 * Construct this widget
	 *
	 * @param	InArgs	The declaration data for this widget
	 */
	void Construct( const FArguments& InArgs )
	{
	    // Order does not matter here but to get the property we need the underscore infront of the value we're getting.
	    bCanBounce = InArgs._CanBounce;
	    Style = InArgs._Style;
	    AdditionalPadding = InArgs._AdditionalPadding;
	    CustomizedScaling = InArgs._CustomizedScaling;
	}

private:

    /** Scaling for after the button is customized */
    float CustomizedScaling;

    /** Style resource for this custom button. */
    const FButtonStyle* Style;
    
    /** Additional padding for what this button needs to display its visuals. */
	TSlateAttribute<FMargin> AdditionalPadding;

    /** Flag to know if this button can be bounced when clicked. */
    TSlateAttribute<bool> bCanBounce;
}
```

Slate Events по сути являются делегатами в SWidgets для привязки при создании виджета, вы можете объявить свой делегат в C++ с помощью этого макроса в объявлении макроса Arguments range.

- `SLATE_EVENT`: Добавляет поддержку обработчика событий для этого виджета с определенной member variable, которая раскрывает делегаты для привязки при создании. Ожидается, что виджет имеет делегат типа `EventDelegateType` с именем, совпадающим с именем события, которое было введено.

Вот пример виджета, который использует макрос события при наведении на него курсора.

```c++
class SMyWidget : public SMyParentWidget
{
    SLATE_DECLARE_WIDGET(SMyWidget, SMyParentWidget)
public:

    SLATE_USER_ARGS( SMyWidget )
    { }

    /** Called when this widget is hovered. */
    SLATE_EVENT( FSimpleDelegate, OnHovered)

    SLATE_END_ARGS()

private:

    /** Called when this widget is hovered. */
    FSimpleDelegate OnHovered; // FSimpleDelegate is within the engine BTW
}
```

<a name="slate-widget-examples"></a>

### 4.10 Slate Widget Examples(Slate Test Suite/Starship Suite)

**Slate Widget Examples** (также известный как **Slate Test Suite** при использовании UE4/**Starship Suite** при использовании UE5) — это собой набор примеров, построенных на Slate, таких как радио-кнопки, адаптивная сетка, выбор цвета и т. д.

Вы можете получить доступ к примерам в Unreal Editor, вот так:

1. В зависимости от того, используете ли вы UE4/UE5
    - UE4: `Window>Developer Tools>Debug Tools`
    - UE5: `Tools/Debug/Debug Tools` <br>![Slate Widget Examples Шаг 1](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/slate_widget_examples_step1.png?raw=true)
2. Выберите `Test Suite` <br>![Slate Widget Examples Шаг 2](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/slate_widget_examples_step2.png?raw=true)

Вы также можете запустить Test Suite как отдельное приложение без открытия Unreal Editor, если у вас есть версия движка bp исходников и собрана программа Test Suite (которая создаст исполняемый файл в `[EnginePath]/Engine/Binaries/Win64/`) .

- UE4
    - `[EnginePath]/Engine/Source/Runtime/AppFramework/Public/Widgets/Testing/STestSuite.h`
    - `[EnginePath]/Engine/Source/Runtime/AppFramework/Private/Widgets/Testing/STestSuite.cpp`
- UE5
    - `[EnginePath]/Engine/Source/Runtime/AppFramework/Public/Widgets/Testing/SStarshipSuite.h`
    - `[EnginePath]/Engine/Source/Runtime/AppFramework/Private/Widgets/Testing/SStarshipSuite.cpp`

![UE4 Test Suite Example](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/ue4_test_suite.png?raw=true) <br> *Test Suite из UE4, сейчас версия Test Suite для UE4 более многофункциональна, чем Starship Suite в UE5.*

<a name="helpful-console-commands-for-slate"></a>

### 4.11 Полезные консольные команды для Slate

> Отладочные команды консоли см. в подразделе «[Отладочные команды консоли](#debug-console-commands)» раздела «[Инструменты разработки и отладки для UMG/Slate](#dev-debug-tools)».

- `Slate.GlobalScrollAmount [float value]` (по умолчанию = 32.0): количество, используемое для прокрутки при каждом щелчке колесика мыши (в Slate Units).

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="umg"></a>

## 5.0 UMG (Unreal Motion Graphics)

Фреймворк UMG представляет собой UObject, который должен быть привязан к определенному **Player Controller**, известному как **Owning Player**(для аккаунта в split screen), если ничего не вводится для Owning Player, он будет автоматически подключен к первому Local Player на уровне.

Иерархия типов объектов UMG представлена ниже:

- **UVisual**: базовый класс для элементов в слотах и виджетах UMG.
    - **UWidget**: базовый класс для всех Widgets, они создают Slate Widgets и обрабатывают функции перенаправления от классов на основе Blueprint/UObject к Slate. Это такие виджеты, как TextBlock, ScrollBox, Button и т. д.
    - **UUserWidget**: базовый класс для проектирования UI, анимирования UI и подключения этой функциональности к коду игры.

User WIdgets строятся из виджетов, за исключением того, что User Widget не требует корневого(root) виджета, в основном аналогично тому, как Actors строятся из нескольких Actor Components и требуют корневого Actor Component (известного как Root Component).

User Widgets не могут наследовать свою иерархию(**Widget Hierarchy**), как Actors делают это с Components, но они могут наследовать функциональность класса (поэтому создание абстрактного User Widget позволит другим классам наследоваться от него или создание класса на C++ позволит наследоваться от него).

<a name="user-widget-hierarchy"></a>

### 5.1 Иерархия User Widgets

Каждый **User WIdget** является корневым `UWidget`, поэтому у User Widget не может быть виджетов внутри него и по умолчанию он считается **Compound Widget**, у которого может быть только один дочерний элемент, но этот элемент может иметь другие дочерние элементы под ним и вызывает эффект каскадирования дочерних виджетов внутри **Tree Hierarchy** каждого User Widget.

Designer/Hierarchy Editor View | Runtime результат
:-: | :-:
![Пример иерархии User Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_hierarchy.png)<br>*`Health_Bar` и `Health_Text` выделены **жирным**, потому что у них включен флаг `Is Variable`*<br>![ Флаг Is Variable](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/is_variable.png) | ![Второй пример Hit Test Grid](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_hierarchy_result.png)

![On Animation Started](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/umg_hierarchy_diagram.png?raw=true) *Пример этой иерархии в виде диаграммы*

<a name="user-widget-animation"></a>

### 5.2 Анимация User Widget

Каждый User Widget может создавать собственные анимации, используя виджеты в этом User WIdget с помощью **Sequencer**. Вы можете создавать эти анимации в конструкторе виджетов, ещё вы можете изменять вещи, относящиеся к этому виджету, такие как преобразование рендеринга (render transform), видимость виджета (widget visibility) и т. д. Вы также можете изменять свойства виджетов, такие как параметры материала, значения рантайма в виджете, и т.п.

![On Added to Focus Path](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/umg_animation_designer.gif?raw=true) *Пример конструктора анимации в UMG*

Если для параметра **Tick Frequency** в User Widget установлено значение **Never** вместо **Auto** в настройках класса по умолчанию, он никогда не будет запускать анимацию, потому что для того, чтобы анимация вообще воспроизводилась, User Widget должен иметь возможность тикать эту анимацию, и если возможность User Widgets тикать выключена (установлено значение tick frequency как never), тогда он не будет тикать объект анимации.

<a name="user-widget-events"></a>

### 5.3 User Widget Events

У каждого User WIdget есть встроенные события (events), которые вы можете реализовать и добавить свои собственные функции;

- **Pre Construct**: Срабатывает как в редакторе в дизайнере, так и до фактического создания виджета, аналогично Construction Script, который можно найти в Actors.

```c++
virtual void UUserWidget::NativePreConstruct()
{
    // Вызвать блюпринтовую версию
    PreConstruct(IsDesignTime());
}
```

![On Focus Lost](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/preconstruct.png)

- **On Initialized**: Срабатывает только один раз во время выполнения, когда создается экземпляр, не являющийся шаблоном (когда вы создаете user widget).

```c++
virtual void UUserWidget::NativeOnInitialized()
{
    // Привязать (bind) input delegates, которые могут быть у этого виджета к владеющуму (owning) им player controller
    if(APlayerController* PC = GetOwningPlayer())
    {
    	UInputDelegateBinding::BindInputDelegates(GetClass(), PC->InputComponent, this);
    }
    
    OnInitialized();
}
```

![Save Zone Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/oninitialized.png)

- **Construct**: Может сработать несколько раз для одного User WIdget, потому что он основан на том, когда виджет построен (Constructed) на экране (Через Add to Viewport или Add to Player Screen). Поэтому, если вы удаляете виджет из родителя (Remove from Parent) и повторно добавляете его позже, рекомендуется не помещать в него код первой инициализации, а вместо этого поместить его в "On Initialized".

```c++
virtual void UUserWidget::NativeConstruct()
{
    // Вызвать блюпринтовую версию
    Construct();
    UpdateCanTick();
}
```

![Tick](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/construct.png)

- **Destruct**: Срабатывает, когда этот виджет больше не отображается на экране, может вызываться несколько раз, поскольку он является инверсией Construct, где он срабатывает, когда этот виджет удаляется из родителя.

```c++
virtual void UUserWidget::NativeDestruct()
{
    StopListeningForAllInputActions();
    // Вызвать блюпринтовую версию
    Destruct();
}
```

![Пример Widget Reflector](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/destruct.png)

- **On Paint**: Срабатывает при отрисовке виджета каждый кадр, отличается от Tick тем, что он предназначен для обработки информации Paint Context.

```c++
virtual int32 UUserWidget::NativePaint(const FPaintArgs& Args, const FGeometry& AllottedGeometry, const FSlateRect& MyCullingRect, FSlateWindowElementList& OutDrawElements, int32 LayerId, const FWidgetStyle& InWidgetStyle, bool bParentEnabled ) const
{
    // Если в Blueprint уже имплементирована эта функция
    if ( bHasScriptImplementedPaint )
    {
    	FPaintContext Context(AllottedGeometry, MyCullingRect, OutDrawElements, LayerId, InWidgetStyle, bParentEnabled);
    	// Вызвать блюпринтовую версию
    	OnPaint( Context );

    	return FMath::Max(LayerId, Context.MaxLayer);
    }

    return LayerId;
}
```

![On Animation Finished](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/onpaint.png)

- **Tick**: Будет срабатывать в каждом кадре, когда этот виджет находится на экране, он не будет тикать, если виджет не отображается (даже если он все еще существует, единственное, что имеет значение, это то, что он отображается, а затем его тиканье).

```c++
virtual void UUserWidget::NativeTick(const FGeometry& MyGeometry, float InDeltaTime)
{
    //...
    
    // If BP implemented the function in the event graph
    if (bHasScriptImplementedTick)
    {
        // Call BP version
    	Tick(MyGeometry, InDeltaTime);
    }
}
```

![On Focus Reveived](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/tick.png)![On Focus Received c двумя видами возвращаемых значений](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/languages/ru/images/user_widget_events/focus_received_both.png?raw=true)

- **On Animation Started**: Происходит, когда анимация виджета начинает воспроизводиться, сообщает, что виджет начал воспроизводить анимацию, на случай, если вам нужно будет проверить его или использовать его позже. (Для пользователей Blueprint: последние версии Unreal требуют, чтобы события завершения анимации отображались в Event Graph, в то время как предыдущие версии позволяют отображать их как переопределяемые функции)

```c++
virtual void UUserWidget::OnAnimationStartedPlaying(UUMGSequencePlayer& Player)
{
    // Вызвать блюпринтовую версию
    OnAnimationStarted(Player.GetAnimation());

    BroadcastAnimationStateChange(Player, EWidgetAnimationEvent::Started);
}
```

![On Added to Focus Path](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/animation_started.png)

- **On Animation Finished**: Срабатывает, когда анимация виджета заканчивает воспроизводиться, сообщает вам про завершение воспроизведения этого виджета на случай, если вам нужно проверить его или использовать его позже. (Для пользователей Blueprint: последние версии Unreal требуют, чтобы события завершения анимации отображались в Event Graph, в то время как предыдущие версии позволяют отображать их как переопределяемые функции)

```c++
virtual void UUserWidget::OnAnimationFinishedPlaying(UUMGSequencePlayer& Player)
{
    // Это событие срабатывает прямо sequence player'ом, когда анимация заканчивается.

    // Вызвать блюпринтовую версию
    OnAnimationFinished(Player.GetAnimation());

    BroadcastAnimationStateChange(Player, EWidgetAnimationEvent::Finished);

    if ( Player.GetPlaybackStatus() == EMovieScenePlayerStatus::Stopped )
    {
    	StoppedSequencePlayers.Add(&Player);

    	if (AnimationTickManager)
    	{
    		AnimationTickManager->AddLatentAction(FMovieSceneSequenceLatentActionDelegate::CreateUObject(this, &UUserWidget::ClearStoppedSequencePlayers));
    	}
    }

    UpdateCanTick();
}
```

![Pre Construct](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/animation_finished.png)

- **Of Focus Received**: (если у вас возникли проблемы с его поиском в Blueprint, он должен вернуть структуру Event Reply, поэтому вам придется переопределить ее в списке функций, а не в Event Graph) Срабатывает, когда фокус передается этому User Widget (только этому виджету). Нужно, чтобы вы возвращали структуру Event Reply, за счёт которой вы можете выбрать возвращаемое значение Handled или Unhandled.

```c++
virtual FReply UUserWidget::NativeOnFocusReceived( const FGeometry& InGeometry, const FFocusEvent& InFocusEvent )
{
    // Вызываем блюпринтовую версию и возвращаем то, что возвращает Blueprint
    return OnFocusReceived( InGeometry, InFocusEvent ).NativeReply;
}
```

![On Initialized](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/focus_received.png)

- **On Added to Focus Path**: Срабатывает, когда этот виджет или дочерний виджет в этом User Widget добавляется в путь фокуса (или находится в фокусе) и ранее не был его частью.

```c++
virtual void UUserWidget::NativeOnAddedToFocusPath(const FFocusEvent& InFocusEvent)
{
    // Вызываем блюпринтовую версию
    OnAddedToFocusPath(InFocusEvent);
}
```

![On Initialized](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/added_to_focus_path.png)

- **On Focus Lost**: Срабатывает, когда этот User Widget (только этот виджет) теряет фокус.

```c++
virtual void UUserWidget::NativeOnFocusLost( const FFocusEvent& InFocusEvent )
{
    // Вызываем блюпринтовую версию
    OnFocusLost( InFocusEvent );
}
```

![Destruct](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/focus_lost.png)

- **On Removed from Focus Path**: Похоже на On Focus Lost, за исключением того, что может сработать, когда дочерний виджет в этом User Widget или сам этот виджет больше не является частью пути фокуса.

```c++
virtual void UUserWidget::NativeOnRemovedFromFocusPath(const FFocusEvent& InFocusEvent)
{
    // Вызвать блюпринтовую версию
    OnRemovedFromFocusPath(InFocusEvent);
}
```

![On Paint](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/user_widget_events/removed_from_focus_path.png)

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="common-widgets"></a>

## 6.0 Common Widgets

В Unreal Engine есть большое количество часто используемых виджетов, его базовых элементов.<br> Большая часть или даже все ваши UI, использующие UMG/Slate, вероятно, будут построены на комбинировании этих виджетов:

-  **Text Block** *[Leaf Widget]*: Обрабатывает отображение статического текста, который можно изменить во время выполнения, установив для него другое текстовое значение. Виджеты TextBlock позволяют использовать пользовательский шрифт (включая его гарнитуру, если у шрифта есть другие), настраивать размер текста, межбуквенный интервал (также известный как кернинг), параметры контура (это сместит отображаемый текст), применять материалы к самим буквам, добавить положение тени или shadow offset (это сместит отображаемый текст), установите его выравнивание (justification) и т. д. <br> ![Text Block Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_textblock.png)
-  **Rich Text Block** *[Leaf Widget]*: Работает аналогично виджетам TextBlock, но позволяет использовать пользовательские изображения, глифы, несколько шрифтов и т. д. для одновременного использования в одном и том же текстовом значении. <br> ![Rich Text Block Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_richtextblock.png)
-  **Image** *[Leaf Widget]*: Обрабатывает отображение либо текстуры, либо материала, который использует UI domain для его отображения. <br>![Image Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_image.png)
-  **Border** *[Compound Widget]*: У него может быть только 1 дочерний виджет. Отображает дочерний виджет перед этим виджетом, по сути это виджет Image, который может иметь дочерний элемент. <br>![Border Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_border.png)
-  **Button** *[Compound Widget]*: У него может быть только 1 дочерний виджет. Отображает перед собой этот дочерний элемент, с которым можно взаимодействовать и на который можно фокусироваться. Возвращается при клике/нажатии/отпускании/удержании/наведении (hovered) и снятии наведения (unhovered). Вы также можете установить его метод Click (кнопкой мыши), метод Touch (у сенсорного экрана) и метод Press (клавиатура и геймпад). <br> ![Button Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_button.png)
-  **CheckBox** *[Leaf Widget]*: Занимается отображением определенного изображения/материала в зависимости от того, в каком состоянии находится флажок, его можно кликнуть (или установить в определенное состояние) а сам он показывает, включено или выключено что-то. <br> ![Checkbox Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_checkbox.png)
- **Progress Bar** *[Leaf Widget]*: Обрабатывает отображение изображения/материала перед этим виджетом с помощью заполнения значения от 0 до 1 с помощью его Bar Fill Type и Bar Fill Style.
    - Типы заполнения (Fill Types):
        -  **Left to RIght**: Заполняет прогрессбар слева направо. <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_left_right_scale.png" class=""> <br> *Вариант заполнения по маске (Masked Version)* <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_left_right_scale.png" class=""> <br> *Вариант заполнения масштабом изображения (Scaled Version)*
    -  **Right to Left**: Заполняет прогрессбар справа налево. <br><img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_right_left_mask.png" class=""><br> *Вариант заполнения по маске (Masked Version)* <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_right_left_scale.png" class=""> <br> *Вариант заполнения масштабом изображения (Scaled Version)*
    -  **Fill from Center**: Линейно заполняет прогрессбар по осям X и Y от центра к краям. <br><img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_center_mask.png" class=""><br> *Вариант заполнения по маске (Masked Version)* <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_center_scale.png" class=""> <br> *Вариант заполнения масштабом изображения (Scaled Version)*
    - **Fill from Center Horizontal**: Линейно заполняет прогрессбар по оси X от центра к краям. <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_center_horizontal_mask.png" class="" width="283.5" height="134.5"> <br> *Вариант заполнения по маске (Masked Version)* <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_center_horizontal_scale.png" class="" width="298" height="144"> <br> *Вариант заполнения масштабом изображения (Scaled Version)*
    -  **Fill from Center Vertical**: Линейно заполняет прогрессбар по оси Y от центра к краям. <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_center_vertical_mask.png" class=""> <br> *Вариант заполнения по маске (Masked Version)* <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_center_vertical_scale.png" class=""> <br> *Вариант заполнения масштабом изображения (Scaled Version)*
    -  **Top to Bottom**: Заполняет прогрессбар сверху вниз. <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_top_bottom_mask.png" class=""> <br> *Вариант заполнения по маске (Masked Version)* <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_top_bottom_scale.png" class=""> <br> *Вариант заполнения масштабом изображения (Scaled Version)*
    -  **Bottom to Top**: Заполняет прогрессбар снизу вверх. <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_bottom_top_mask.png" class=""> <br> *Вариант заполнения по маске (Masked Version)* <br> <img src="https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/progress_bars/w_progressbar_bottom_top_scale.png" class=""> <br> *Вариант заполнения масштабом изображения (Scaled Version)*
    - Варианты заполнения (Fill Styles):
        - По маске/**Mask**: Изображение-заполнитель прогрессбара маскируется в зависимости от процента заполнения и типа заполнения (fill type).
        - Масштабом/**Scale**: Изображение-заполнитель масштабируется и растягивается/сжимается в зависимости от процента заполнения и типа заполнения (fill type).
    -  **Slider** *[Leaf Widget]*: Похож на прогрессбар, но с ним можно взаимодействовать, и вы можете изменить его ориентацию с горизонтальной на вертикальную и установить размер шага (для нажатий с клавиатуры/геймпада). <br> ![Slider Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_slider.png)
-  **Editable Text** *[Leaf Widget]*: Поле, в котором пользователь может ввести одну строку текста, может иметь текст подсказки и иметь включенный параметр "только для чтения", может быть полем для ввода пароля (когда вместо реального текста показываются точки), а может настраиваться, как обычный виджет Text Block. <br> ![Editable Text Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_editable_text.png)
-  **Editable Text (Multi-Line)** *[Leaf Widget]*: То же самое, что и виджет Editable Text, разве что пользователь может вводить несколько строк текста вместо одной. <br> ![Editable Text (Multi-Line) Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_editable_text_multi.png)
-  **Text Box** *[Leaf Widget]*: То же, что и Editable Text, разве что обёрнут изображением/материалом позади текста. <br> ![Text Box Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_textbox.png)
-  **Text Box (Multi-Line)** *[Leaf Widget]*: То же, что и Editable Text(Multi-Line), разве что обернут изображением/материалом за текстом. <br> ![Text Box (Multi-Line) Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_textbox_multi.png)
-  **Spin Box** *[Leaf Widget]*: Показывает число (можно разрешить или запретить использование десятичных знаков), которое пользователь может ввести или использовать мышь и взаимодействовать с ним для перемещения и увеличения/уменьшения числа. <br> ![Spin Box Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_spinbox.png)
-  **Combo Box (String)** *[Leaf Widget]*: Виджет раскрывающегося списка, который отображает строковое (string, НЕ TEXT, поэтому его нельзя локализовать) значение при выборе, а также отображает его параметры. <br>![Combo Box Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_combobox.png)
- **Invalidation Box** *[Compound Widget]*: У него может быть только 1 дочерний виджет. Будет контролировать, когда этот дочерний виджет становится невалидным для его проходов макета/геометрии (layout/geometry passes), что очень полезно для повышения производительности. *На самом деле не может использовать картинку, потому что полностью оборачивает виджет и невидим*.
-  **Retainer Box** *[Compound Widget]*: У него может быть только 1 дочерний виджет. Будет отображать материал поверх своего дочернего виджета и только своего дочернего виджета, то есть не будет отображать этот материал по остальному пространству на фоне, которое дочерний виджет не занимает при отрисовке.<br> Например, если вы оборачиваете Text Block виджетом Retainer Box, материал будет применяться только к тексту, а не к пространству между буквами. <br> ![Retainer Box Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_retainerbox.png)<br> *Иерархия Retainer Box в дизайнере* <br> ![Retainer Box Material Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_retainerbox_material.png)<br> *Материал Retainer Box* <br>![Результирующий Retainer Box Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_retainerbox_result.png)<br> *Retainer Box в рантайме (во время play in editor)*
-  **Throbber** *[Leaf Widget]*: Отображает изображение/материал в определенном анимированном шаблоне. Полезно для показа того, что что-то загружается. <br>![Throbber Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_throbber.png)
- **Circular Throbber** *[Leaf Widget]*: Версия Throbber, которая перемещает изображения/материалы по кругу. <br> ![Circular Throbber Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_throbber_circular.png)
    - > *Примечание от автора; «Пожалуйста, измените изображение Throbber на что-то отличное от изображения по умолчанию в ваших финальных продуктах, если это возможно. Я устал видеть дефолтный троббер в выпущенных продуктах, вы можете сделать лучше! Спасибо."*
- **Spacer** *[Leaf Widget]*: Этот виджет не имеет визуального представления, а просто обеспечивает заполнение и промежуток между другими виджетами, рекомендуется использовать его вместо отступов (padding) в слотах, если ваш дизайн UI постоянно меняется, чтобы упростить быструю итерацию.
-  **Background Blur** *[Compound Widget]*: У него может быть только 1 дочерний виджет. По сути, виджет Image с дочерним элементом, отображаемым позади него, размывает результат отображения этого дочернего виджета с помощью размытия по Гауссу. <br> Рекомендуется использовать его с правильной настройкой области отсечения (clipping area), иначе лучше использовать кастомный материал, чтобы художникам было легче вносить изменения. <br> ![Background Blur Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_background_blur.png)
-  **Input Kay Selector** *[Leaf Widget]*: Позволяет пользователю нажать клавижу ввода, когда этот виджет в фокусе, и он будет отображать, какая это клавиша ввода. <br>![Input Key Selector Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_input_key_selector.png)
-  **Canvas Panel** *[Panel Widget]*: Это виджет по умолчанию, который можно найти свожесозданном User Widget. Он позволяет разработчику размещать дочерние виджеты в произвольных местах, привязывая их к якорным точкам (anchors) и располагая по оси z с другими дочерними элементами этого холста (canvas).<br> Он использует макет gj абсолютным параметрам для своего размещения, поэтому он хорош для экранных индикаторов, которые следуют за определенным объектом в мире или чем-то, что может перемещаться по всему экрану. <br>![Canvas Panel Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_canvas_panel.png)
-  **Horizontal Box** *[Panel Widget]*: Позволяет размещать свои дочерние виджеты в горизонтальном порядке, двигаясь слева направо от нулевой позиции — крайнего слева виджета, так, что последний виджет — крайний справа. <br>![Horizontal Box](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_horizontalbox.png)
-  **Vertical Box** *[Panel Widget]*: Работает так же, как и Horizontal Box, за исключением того, что он размещает свои дочерние элементы в вертикальном порядке, двигаясь сверху вниз, от нулевой позиции в качестве самого верхнего виджета, когда последний виджет является самым нижним виджетом.<br> *Vertical Box и Horizontal Box не прокручиваются (не скролятся), для этого вам придется использовать виджет Scroll Box или что-то подобное.* <br>![Vertical Box Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_verticalbox.png)
-  **Scroll Box** *[Panel Widget]*: Работает так же, как Vertical Box И Horizontal Box (должно быть установлено либо вертикальное, либо горизонтальное положение), но позволяет их прокручивать (скролить). Не поддерживает виртуализацию. <br> ![Scroll Box Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_scrollbox.png)
-  **Size Box** *[Compound Widget]*: У него может быть только 1 дочерний виджет. Позволяет этому виджету указать желаемый размер (desired size) своего дочернего виджета (поскольку не все виджеты будут сообщать о желаемом размере, так как зависят от своих собственных дочерних виджетов). <br> ![Size Box Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_sizebox.png)
-  **Scale Box** *[Compound Widget]*: У него может быть только 1 дочерний виджет. Позволяет этому виджету масштабировать свой дочерний элемент, чтобы тот соответствовал конкретному размеру в области, занимаемой этим боксом. <br> ![Scale Box Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_scalebox.png)<br> *В этом примере Scale Box изменяет размер Image, чтобы оно умещалось без перекосов*
-  **Overlay** *[Panel Widget]*: Отображает виджеты друг над другом, в зависимости от их порядка в списке дочерних виджетов. Этот виджет чрезвычайно полезен для быстрого наложения виджета поверх другого виджета. <br>![Overlay WIdget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_overlay.png)<br> *Текст и изображение являются дочерними элементами Overlay Widget.*
-  **Grid Panel** *[Panel Widget]*: Позволяет автоматически размещать дочерние виджеты по сеткоподобному паттерну, напоминающему таблицу, которая сохраняет ширину каждого столбца. <br>![Grid Panel Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_gridpanel.png) *Эта сетка была настроена так, чтобы заполнять пространство между каждым столбцом и строкой, то есть ваша сетка может выглядеть по-разному в зависимости от того, как вы ее настроили.*
-  **Uniform Grid Panel** *[Panel Widget]*: По сути Grid Panel, но он будет равномерно делить доступное пространство между всеми своими дочерними элементами. <br>![Uniform Grid Panel WIdget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_uniformgrid.png)
- **Widget Switcher** *[Panel Widget]*: Будет отображать только один из своих дочерних виджетов за раз исходя из его дочернего индекса, но будет загружать их все сразу (не подходит для главных страниц интерфейса, только для небольших вещей) и инициализировать, создавать (construt) их все, когда переключатель виджетов загружается, инициализируется, создается (construct).
- **Save Zone** *[Compound Widget]*: У него может быть только 1 дочерний виджет. Этот виджет особенный, поскольку он будет применять отступы к верхней/нижней/левой/правой сторонам своего дочернего виджета внутрь, учитывая, на каком устройстве отображается этот виджет, например, на некоторых мобильных устройствах с "бровью" (notch) на одной стороне, безопасная зона будет учитывать это и добавлять отступы к своему дочернему виджету, чтобы он не обрезался "бровью", а также учитывать телевизоры с дополнительными пикселями под рамкой, проекторы с дополнительными столбцами пикселей, скрытыми за черной рамкой, и т. д. Хорошим примером является то, что для некоторых телефонов с "бровью" (вы знаете, о каких я говорю), безопасная зона будет расширять эту сторону экрана для вас, чтобы ваши виджеты не закрывались выемкой.

> Вы также можете использовать некоторые полезные отладочные команды консоли для имитирования безопасной зоны на ПК в редакторе, расположенные в подразделе [Отладочные команды консоли](#debug-console-commands) раздела [Инструменты разработки и отладки для UMG/Slate](#dev-debug-tools).

![Save Zone Widget](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widgets/w_safezone.png)<br> *В этом примере мы обернули Canvas Panel виджетом Save Zone, чтобы тот отодвинул canvas от области экрана, которая была бы недоступна из-за выреза на экране или особенностей операционной системы.*

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="common-widget-functionality"></a>

## 7.0 Функционал Common Widgets

У каждого виджета есть свои собственные функциональность и возможности, но при этом есть общая функциональность для всех виджетов, например:

- **Accessibility**: Каждый виджет будет слушать настройки проекта по умолчанию для доступности, эти настройки могут быть переопределены для каждого виджета и могут влиять на его дочерние элементы, <br> изучение доступности выходит за рамки этого документа, но вот официальный курс, одобренный Epic: <br> [Одобренный Epic курс по введению в доступный дизайн](https://www.unrealengine.com/en-US/onlinelearning-courses/introduction-to-accessible-design-with-unreal-engine). <br> ![Accessibility Fields Overview](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/accessibility_overview.png)
    - **Override Accessible Defaults**: если этот параметр включен, поведение специальных возможностей по умолчанию и текст для этого виджета переопределяются.
        - **Can Children be Accessible**: Переключатель, определяющий, должны ли дочерние элементы этого виджета быть отдельно доступными виджетами.
        -  **Accessible Behavior**: Настройка специальных возможностей этого виджета, включая его описание. При использовании опции "своё" (custom) вы можете ввести свой собственный текст специальных возможностей. ![Обзор Accessibility Behavior](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/accessibility_behavior.png)
        -  **Accessible Summary Behavior**: Настройка описания этого виджета, когда он представлен через сводку родительского виджета. При использовании опции "своё" (custom) вы можете ввести свой собственный текст для специальных возможностей. ![Обзор Accessibility Summary Behavior](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/accessibility_summary_behavior.png)
-  **Tool Tip Text**: Текстовый виджет всплывающей подсказки, который использует либо виджет по умолчанию, либо ваш собственный пользовательский виджет, который показывается, когда пользователь наводит курсор мыши на виджет. <br> ![Поле Tool Tip Text](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/tooltip_text.png)
-  **Is Enabled**: Переключатель, определяющий, включен/отключен этот виджет и может ли пользователь интерактивно работать с ним. <br>![Переключатель Is Enabled](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/is_enabled.png)
- **Visibility**: Возможность отрисовки и интерактивного взаимодействия с виджетом.
    - **Visible**: Отрисовывает виджет и разрешает ему реагировать на курсор.
    - **Collapsed**: Не отрисовывает виджет, не даёт ему реагировать на взаимодействие и не даёт ему занимать место в макете (layout).
    - **Hidden**: Не отрисовывает виджет, не даёт реагировать на взаимодействие, но позволяет виджету занимать место в макете (layout).
    - **Not Hit-Testable/Hit Test Invisible (Self &amp; All Children)**: Отрисовывает виджет, но не даёт ему и его дочерним элементам реагировать на взаимодействие.
    -  **Not Hit-Testable/Hit Test Invisible (Self Only)**: Отрисовывает виджет, но делает так, что только этот самый виджет не реагирует на взаимодействие. <br>![Обзор вариантов Visibility](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/visibility_overview.png)
-  **Render Opacity**: Непрозрачность рисуемого виджета, что также влияет на непрозрачность его дочерних элементов. 0 = Невидимый, 1 = Полностью видимый. <br>![Render Opacity](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/render_opacity.png)
- **Render Transform**: У каждого виджета есть размер при отрисовке (Render Transform), который может повлиять на форму финального отрисованного виджета, не меняя исходный макет (layout) и paint information.<br> Думайте об этом как о модификаторе исходной информации о преобразовании, который не меняет макет (layout).
    - **Translation**: Сдвиг местоположения по осям X и Y.
    - **Масштаб**: Масштаб виджета по осям X и Y.
    - **Сдвиг** : Сдвиг виджета по осям X и Y, также известный как перекос.
    - **Shear**: Поворот виджета. Вам нужна только 1 ось для вращения в 2D-пространстве, но она иметь значение в диапазоне от -180 до 180 градусов.
    -  **Pivot**: Смещение опорной точки (pivot point) виджета, которая определяет положение, из которого применяются преобразования.<br> Фактическое значение представляет собой приведённую величину, начинающуюся с 0,5 по осям X/Y для центра виджета, 0,0 = слева/сверху и 1,0 = справа/снизу. <br> ![Render Transform](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/render_transform.png)
-  **Is Volatile**: Этот переключатель, если установлено значение true, будет помечать этот виджет как некэшируемый, поэтому он всегда должен обновлять свой макет (layout) и финальную форму (collision geometry). По умолчанию параметр равен false, потому что он обычно не используется, но предлагается на всякий случай. ![Is Volatile](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/is_volatile.png)
- **Clipping**: В зависимости от макета (layout) и формы (geometry information), здесь вы можете указать, как виджет обрезается,<br> при этом области обрезания разных виджетов не объединяются, то есть это может повлиять на производительность в зависимости от того, сколько перекрывающихся и отсеченных виджетов у вас есть на экране. <br> ![Обзор Clipping](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/clipping_overview.png)
    -  **Inherit**: Этот clipping space не позволяет виджету обрезать свои дочерние элементы, но виджет и все его дочерние элементы наследуют область отсечения последнего виджета, который был обрезан выше по иерархии. <br>![Пример Inherit Clipping](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/clipping_inherit.png)<br> *В этом примере есть виджет `Scroll Box` с Clipping, установленным на `Inherit`, и он является дочерним элементом виджета `Canvas Panel`, у которого Clipping установлен на `Clip to Bounds`.*
    -  **Clip to Bounds**: Этот clipping space обрезает границы своего виджета, он пересекает эти границы с любой предыдущей clipping area выше него по иерархии. <br>![Пример Clip to Bounds](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/clipping_clip_to_bounds.png)<br> *В этом примере есть виджет `Scroll Box` с Clipping, установленным на `Clip to Bounds`, поэтому его дочерние виджеты, которые являются `Button`, будут пересекаться, когда они выходят за границы `Scroll Box`.*
    -  **Clip to Bounds - Without Intersecting(Advanced)**: Эта clipping area также обрезается до своих границ, но **<u>НЕ</u>** пересекается ни с какой существующей clipping area, она всегда будет "продавлилвать" свое собственное новое состояние Clipping.<br> Позволяет виджету отрисовываться за пределами тех границ, под которые обрезается вся его иерархия. Однако это **<u>НЕ</u>** позволит вам игнорировать clipping area, для которой установлено значение *"Always"*. <br>![Пример Clip to Bounds Without Intersecting](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/clipping_clip_to_bounds_intersect.png)<br> *В этом примере есть виджет `Scroll Box` с Clipping, установленным на `Clip to Bounds` а один из его дочерних виджетов имеет Clipping, установленный на `Clip to Bounds - Without Intersecting(Advanced)`*
    -  **Clip to Bounds - Always(Advanced)**: Эта clipping area также обрезает границы и всегда пересекает эти границы с любой предыдущей clipping area.<br> Эту clipping area **<u>НЕЛЬЗЯ</u>** игнорировать, она всегда будет обрезать свои дочерние элементы. Полезно для жестких барьеров в UI, где вы никогда не хотите, чтобы анимация или другие эффекты врывались в или вырывались из этой области. <br>![Пример Clip to Bounds Always](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/clipping_clip_to_bounds_always.png)<br> *В этом примере есть 3 основных виджета;<br> `Canvas Panel` с Clipping, установленным на `Clip to Bounds - Always(Advanced)`<br> `Scroll Box` в `Canvas Panel` с Clipping, установленным на `Clip to Bounds`<br> `Button` в `Scroll Box`, для которой установлено значение `Clip to Bounds - Without Intersecting(Advanced)`*
    -  **On demand(Advanced)**: Эта clipping area обрезается до границы, когда ее desired size больше, чем выделенная геометрия в макете (layout).<br> Если это происходит там, где его нужно обрезать, то она будет рассматриваться как *"Always"*. Согласно исходникам, этот режим был в первую очередь добавлен для текста, когда тот помещается в контейнер, размер которого в конечном итоге изменяется, чтобы не поддерживать длину текста. <br>![Пример Clipping On Demand](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/images/common_widget_func/clipping_on_demand.gif)<br> *В этом примере у нас есть виджет `Vertical Box` с Clipping, установленным на `Inherit`, и кастомный `Text Block` из эпиковского плагина Common UI, для которого Clipping установлен на `On Demand(Advanded)`, чтобы текст мог прокручиваться и обрезаться должным образом (этот пример также встречается в проекте эпиков Context Examples на карте Common UI Example)*
- **Navigation**: Здесь вы можете добавить свои навигационные хуки для определения того, к какому виджету следует переходить при использовании фреймвока фокуса Unreal. Вы можете установить их в рантайме в Blueprint и в C++.<br> Пожалуйста, обратитесь к разделу [Система фокусироки Unreal](#unreals-focusing-system) для более подробного объяснения процесса навигации. <br>![Обзор Navigation](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/navigation_overview.png)
    -  **Escape**: Этот тип навигации будет переходить либо к другому виджету, либо пытаться добраться до любого другого виджета и выйти за пределы этого виджета при перемещении в этом направлении. <br>![Пример Escape Navigation](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/navigation_escape.png)
    -  **Stop**: Навигация останавливается при попытке выйти из этого виджета в этом направлении. <br>![Пример Stop Navigation](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/navigation_stop.png)
    -  **Wrap**: Навигация будет пытаться перейти к противоположным границам этого виджета (например, в Vertical Box, переход к нижнему виджету и наличие настройки обтекания (wrap) для нижнего виджета на последнем виджете отправит навигацию к верхнему виджету Vertical Box). <br>![Пример Wrap Navigation](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/navigation_wrap.png)
    -  **Explicit**: Навигация к специально выбранному виджету при переходе от этого виджета в этом направлении. <br>![Пример Explicit Navigation](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/navigation_explicit.png)<br> *Вы можете выбирать только другие виджеты, имя которых изменено в редакторе, при выборе его в дизайнере, тогда как в коде вы можете просто предоставить сам виджет, независимо от того, был ли он переименован или нет.*
    -  **Custom**: позволяет переопределить виджет для перехода с помощью функции, которая может либо возвращать виджет, либо не возвращать виджет (имитируя тип навигации *"Stop"*). Предназначен для перехода **ОТ** или из этого виджета к другому виджету в этом конкретном направлении. <br>![Пример Custom Navigation](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/navigation_custom.png)
    -  **Custom Boundary**: Позволяет переопределить, к какому виджету переходить, используя функцию, которая может либо возвращать виджет, либо не возвращать виджет (имитируя тип навигации *"Stop"*). Предназначен для перехода **к** этому виджету от другого виджета в этом конкретном направлении,<br> поэтому, если для направления Влево/Left и вы установили для него "Custom Boundary", тогда, когда вы переходите от другого виджета к этому, и это было направление Влево/Left, он будет запускать эту функцию, к которой он привязан. <br> ![Пример Custom Boundary Navigation](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/navigation_custom_boundary.png)
- **Flow Direction**: При локализации позволяет вам установить направление написания текста этого виджета, то есть слева направо или справа налево.<br> На самом деле его используют только некоторые виджеты, но он есть во всех виджетах на тот случай, если вы захотите добавить свои собственные функции, зависящие от направления написания. Например, текстовые виджеты могут переворачиваться слева направо/справа налево в зависимости от направления их написания и языка, который определяет его направление написания.
    - **Inherit**: Наследует направление написания, заданное родительским виджетом.
    - **Culture**: Начинает писать текст виджетов с использованием текущего предпочтения направления написания, принятый для языка, меняя направление написания.
    - **Left to Right**: Требует всегда писать текст слева направо.
    -  **Right to Left**: Требует всегда писать текст справа налево. <br>![Параметры Flow Direction](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/common_widget_func/flow_direction_preference.png)

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="umg-in-relation-to-levels-worlds"></a>

## 8.0 UMG в контексте миров (Levels)

<a name="hud-actors"></a>

### 8.1 HUD Actors

HUD Actors — это Actors, которые появляются на уровне только силами Game Mode (я не рекомендую создавать их вручную, если вы не переопределяете функциональность игрового режима и не знаете, что делаете). Эти акторы не реплицируются, по умолчанию скрыты и создаются только для Local Player Controller (для аккаунта в split screen) и не появляются на dedicated серверах.

Назначение HUD Actors изменилось с релизом Unreal Engine 4 (оно осталось прежним для Unreal Engine 5) по сравнению с тем, что было в Unreal Engine 3, где раньше это были основные источники функциональности для UI-элементов на уровне для каждого игрока, но с выпуском UMG и Slate стало так, что HUD Actors стали объектами-менеджерами для UI-элементов UMG/Slate, а не драйверами каждого аспекта функциональности UI, но они совершенно необязательны в контексте того, как вы хотите спроектировать свою архитектуру.

<a name="hud-drawing"></a>

#### 8.1.1 Отрисовка HUD

HUD Actors привязаны к конкретному Player Controller и содержат отладочную информацию, а также функциональность для ручного рисования элементов UI на экране. Вот список рисуемых элементов UI:

- Text: Рисует строку на холсте (canvas) вьюпорта.
- Line: Рисует 2D-линию на canvas вьюпорта в 2D-пространстве экрана.
    - 2D Line: Рисует 2D-линию на canvas вьюпорта, используя координаты пикселей (которые могут быть менее точными, чем экранное пространство, из-за того, как Unreal использует Slate Units).
    - 3D Line: Просит отладочную систему рисования линий для мира рисовать линию прямо в мире.
- Rect: Рисует нетекстурированный четырехугольник (квадрат/прямоугольник) на canvas вьюпорта.
- Texture: Рисует текстурированный четырехугольник (квадрат/прямоугольник) на canvas вьюпорта.
    - Texture Simple: Рисует текстурированный четырехугольник (квадрат/прямоугольник) с плотностью текселей 1:1 на canvas вьюпорт.
- Material: Рисует четырехугольник (квадрат/прямоугольник) с текстурой материала на canvas вьюпорта.
    - Material Simple: Рисует четырехугольник (квадрат/прямоугольник) с текстурой материала на canvas вьюпорта, но предполагает, что UV равны (0,0, 0,0) и (1,0, 1,0).
    - Material Triangle: Рисует треугольную форму с текстурой материала на canvas вьюпорта.

> Важным примечанием является то, что HUD Actor рисует изображения и другие элементы UI, пропуская несколько шагов, которые делает UMG, напрямую получая холст и приказывая ему рисовать элементы.

<a name="hud-hitboxes"></a>

#### 8.1.2 Хитбоксы HUD

Интересная особенность HUD Actors заключается в том, что они могут знать, были ли наведены (moused over)/кликнуты/нажаты или отжаты части экрана. Они делают это с помощью класса `FHUDHitBox`.

`FHUDHitBox` — это класс только для C++, который имеет следующие свойства:

- Coords `FVector2D`: Координаты левого верхнего угла хитбокса.
- Size `FVector2D`: Размер хитбокса.
- Name `FName`: Имя хитбокса.
- bConsumesInput `boolean`: Не принимает реальный ввод из игры.
    - True: Запрещает проверки попаданий (hit checks) в другие хитбоксы.
    - False: Позволяет проверке попаданий (hit check) пройти насквозь к другим хитбоксам.
- Priority `int32`: Приоритет хитбокса (может также рассматриваться как глубина или Z-order). В первую очередь приоритет отдается хитбоксам, которые располагаются выше остальных.

Преимущество использования `FHUDHitBox` заключается в том, что у HUD есть mouse events, которые работают с ним, и каждое событие предоставляет имя HitBox:

- Click: Срабатывает при нажатии на хитбокс.
- Release: Срабатывает, когда хитбокс больше не нажимается.
- Begin Cursor Over: Происходит при наведении курсора мыши на хитбокс.
- End Cursor Over: Происходит, когда на хитбоксе больше нет курсора мыши.

У HUD Actor, по сути, есть массив хитбоксов HUD, которые можно добавлять/удалять в рантайме. Массив является public переменной во всех HUD Actors, но доступ к ней возможен только в C++: `HitBoxMap` (я знаю, что там написано Map, но это не map array).<br> Существует два способа добавления HitBox:

- Вызов `AddHitBox` и ввод параметров для создания класса `FHUDHitBox` внутри функции.
- Создание класса `FHUDHitBox` вручную и добавление его в массив `HitBoxMap` .

Чтобы удалить HitBox, вы можете просто удалить его из массива `HitBoxMap` .

<a name="widget-components"></a>

### 8.2 Widget Components

Компоненты виджетов - это `UMeshComponent`'ы (actor components, которые являются примитивными компонентами, способными рендерить меш), которые в основном создают процедурный static mesh в мире, текстурой которой является нарисованная текстура виджета (вы можете получить доступ к render target, используя `GetRenderTarget`).

> Компоненты виджетов НЕ ТИКАЮТ на Dedicated Servers. <br> Это очевидно, поскольку большая часть функциональности компонента заключается в обновлении рендеринга User Widget. <br> Компонент также работает с коллизиями на основе User Widget, поэтому если виджет не спавнится на Dedicated Servers, то коллизии компонента не будут работать должным образом.

Важное влияние на производительность при использовании компонентов виджетов заключается в том, что каждый компонент виджета является render target, обновляемым по тику компонента. <br> Таким образом, если у вас 100 компонентов виджетов с высоким разрешением, то это 100 render targets, обновляемых каждый кадр (вы можете сделать так, чтобы компонент обновлялся при отрисовке, но это все равно займет память GPU). <br> Чтобы избежать такого воздействия на память GPU, вот несколько распространенных ситуаций и решений (ЭТО НЕ ЕДИНСТВЕННЫЙ ПУТЬ РЕШЕНИЯ ЭТИХ ВОПРОСОВ, ЭТО ПРОСТО РЕКОМЕНДАЦИИ ИЗ МОЕГО ЛИЧНОГО ОПЫТА):

- Ситуация 1: Большое количество изображений или прогресс-баров, которые находятся над головой NPC
    - Решение: Использование static mesh components с материалами с параметром текстуры для изображения и материалом для создания прогресс-бара либо с помощью текстуры, либо с помощью математики (рекомендую посмотреть примеры SDF в Unreal).
- Ситуация 2: Рендеринг индикаторов по всему миру, но масштабируется по мере приближения/отдаления камеры игрока от места расположения индикатора.
    - Решение: Создайте материал для игнорирования depth pass, в последних версиях Unreal Engine также есть булево значение для пропуска motion blur pass, но вы можете сделать это, изменив движок в предыдущих версиях. Вы можете сделать это с помощью static mesh components или particle systems, рисующих static mesh, профилируйте и сделайте собственные выводы.

Чтобы строительные материалы работали с компонентами виджета, вот параметры текстуры, которые автоматически работают с компонентами виджета:

- `SlateUI`: Вводит Render Target виджета.
- `TintColorAndOpacity`: Вводит свойство TintColorAndOpacity компонента виджета.
- `OpacityFromTexture`: Вводит свойство OpacityFromTexture компонента виджета.

Важно помнить, что хотя это и компонент, он фактически создает User Widget. <br> Для доступа к User Widget можно использовать `GetUserWidgetObject` (вы также можете использовать `GetSlateWidget` для получения `SWidget`, к которому он привязан).

> Вы не можете использовать `GetUserWidgetObject` в construction script актора, поскольку виджет может валидироваться только с `BeginPlay`.

По умолчанию он получает первого локального игрока из game instance:

```c++
if (UWorld* LocalWorld = GetWorld())
{
	UGameInstance* GameInstance = LocalWorld->GetGameInstance();
	check(GameInstance);

	return GameInstance->GetFirstGamePlayer();
}
```

Это можно изменить, вызвав `SetOwnerPlayer` и введя `ULocalPlayer`.

Для получения местоположения в пространстве 2D-плоскости виджета от местоположения в мире на компоненте виджета можно использовать `GetLocalHitLocation`, который вычисляет его, выполняя следующие математические операции:

> 1. Путем преобразования мирового местоположения в относительное пространство компонента виджета с помощью `InverseTransformPosition`
> 2. Строит простое 2D местоположение, где ось X является отрицательной осью Y относительного местоположения, а отрицательная ось Z относительного местоположения для 2D оси Y.
> 3. Смещает (добавляет) 2D ось X на ось X текущего размера рисунка * ось X Pivot.
> 4. Смещает (добавляет) ось Y 2D на ось Y текущего размера рисунка * ось Y Pivot.
> 5. Кэширует нормализованное местоположение 2D местоположения, деленное на текущий draw size.
> 6. Обновляет ось Y 2D местоположения на ось Y текущего размера рисунка * нормализует ось Y местоположения, чтобы учесть искажение параболы.

<a name="widget-interaction-components"></a>

#### 8.2.1 Widget Interaction Components

Для возможности взаимодействия с компонентами виджетов существует компонент Widget Interaction Component, который <br> предназначен для имитации пользовательского ввода и ввода указателя мыши (или кончика виртуального пальца) в стиле лазерной указки при взаимодействии с виджетом.

У каждого widget interaction component есть виртуальный пользователь, связанный с ним, который обрабатывает ввод данных для slate widgets. <br> При активации компонент создает фактического `FSlateUser` для имитации ввода и т.п. <br> По умолчанию движок будет использовать индекс Slate User 8 (максимально допустимое количество пользователей) вместо 0 и увеличивать его, <br> позволяя пользователям slate и виртуальным пользователям не конфликтовать.

Widget Interaction Components будут отслеживать по тику, чтобы определить, с каким виджетом он взаимодействует. <br> Вот порядок тикового кадра для компонента, чтобы определить компонент, против которого он делает line tracing в `UWidgetInteractionComponent::TickComponent`:

> 1. `UWidgetInteractionComponent::SimulatePointerMovement`
>     1. Проверьте, можем ли мы вообще делать hit test, установив `bEnableHitTesting`.
>     2. Проверьте, может ли компонент отправлять ввод в `CanSendInput`
>         1. Если приложение slate инициализировано и если virtual user был настроен.
>     3. `UWidgetInteractionComponent::DetermineWidgetUnderPointer`
>         1. Кэширует ранее hovered компонент виджета.
>         2. `UWidgetInteractionComponent::PerformTrace`
>             1. Line trace на основе типа `InteractionSource`:
>             - Мир: Multi-Line Trace по `TraceChannel` в направлении вперед от местоположения компонента взаимодействия, <br> игнорирует любые компоненты в owning actor, чтобы не делать hit себя (исключая компоненты виджета).
>             - Мышь: Multi-Line Trace по `TraceChannel` от позиции мыши, проецируемой с экрана на мир.
>             - Center Screen: Multi-Line Trace по `TraceChannel` из центральной позиции видового экрана, проецируемая с экрана на мир.
>             - Custom: Использует свойства `CustomHitResult`, которые могут быть установлены в runtime. <br> Важное замечание об этой структуре - в первом тиковом кадре она может быть еще не установлена, так как тик Blueprint может произойти после вызова этой структуры. <br> Вы можете установить его в BeginPlay, и он будет установлен заранее для этого первого тикового кадра.
>             1. Если мы не используем пользовательский тип `InteractionSource`, то фильтруйте invisible виджеты.
>             2. Получает компонент виджета попадания и передает hit result, после чего компонент виджета возвращает 2D hit location в пространстве виджета.
>             3. Находит `FWidgetPath` из возвращаемого hit location в пространстве виджета.
>             4. Возвращает результат трассировки `PerformTrace`.
>         3. Сообщите вновь hovered компоненту виджета о необходимости перерисовки.
>         4. Итерация по упорядоченному списку виджетов из полученного widget path из трассировки и обновление этих флагов на основе последнего виджета:
>             - `bIsHoveredWidgetInteractable`: Если виджет является интерактивным.
>             - `bIsHoveredWidgetFocusable`: Если виджет keyboard focusable.
>             - `bIsHoveredWidgetHitTestVisible`: Если виджет hit testible.
>         5. Если вновь hovered компонент виджета отличается от ранее наведенного компонента виджета, то сообщить предыдущему компоненту о необходимости перерисовки. И сделать broadcast `OnHoveredWidgetChanged` для других систем.
>         6. Возвращает путь виджета из трассировки.
>     4. Сообщите приложению slate (для передачи в остальную часть движка), что на этом виджете симулируется ввод или, если мы больше ничего не hovering, сообщить, что указатель переместился с этого старого виджета.

<a name="widget-components-rendering"></a>

#### 8.2.2 Как Widget Components отрисовываются

Для рисования user widget в `UTextureRenderTarget2D` используется общий процесс, который делают Widget Component'ы (наряду с дополнительной работой, потому что это компонент и поэтому должен предоставлять scene proxy и тому подобное); это создание `FWidgetRenderer`, а затем получение slate wudget из user widget и отрисовка виджета в виде текстуры. <br> Вот пример кода использования рендерера виджетов для создания текстуры из `UUserWidget` (существует несколько реализаций `FWidgetRenderer::DrawWindow` &amp; `FWidgetRenderer::DrawWidget`, так что это один из способов):

```c++
bool UExampleFunctionLibrary::DrawWidgetToTarget(UTextureRenderTarget2D*& DrawnWidgetRenderTarget,
    UUserWidget* WidgetToRender, const FVector2D DrawSize, const float DeltaTime)
{
    // Reset the variable for Blueprint users to avoid reusing previous calls
    DrawnWidgetRenderTarget = nullptr;
    // Are we using a valid widget to grab from for the render target
    if(!IsValid(WidgetToRender))
    {
        UE_LOG(LogExampleFunctionLibrary, Error, TEXT("UExampleFunctionLibrary::DrawWidgetToTarget: Inputted NULL WidgetToRender"));
    	return false;
    }
    // Make sure we're using a valid draw size
    if(DrawSize.X <= 0 || DrawSize.Y <= 0)
    {
        UE_LOG(LogExampleFunctionLibrary, Error, TEXT("UExampleFunctionLibrary::DrawWidgetToTarget: Inputted INVALID DrawSize(%s)"), *DrawSize.ToString());
    	return false;
    }
    // Create the render target object using the user widget as the outer object(as a safety measure)
    DrawnWidgetRenderTarget = NewObject<UTextureRenderTarget2D>(WidgetToRender);
    // Setup the render target's size and formatting
    DrawnWidgetRenderTarget->InitCustomFormat(DrawSize.X, DrawSize.Y,
    	FSlateApplication::Get().GetRenderer()->GetSlateRecommendedColorFormat(),
    	true); // If we set this to false then it will not use linear gamma, but then we wouldn't get accurate coloring
    
    // This is the object that handles talking with the slate renderer to draw widgets as textures
    FWidgetRenderer* WidgetRenderer = new FWidgetRenderer(true, false); // FWidgetRenderer(bool bUseGammaCorrection = false, bool bInClearTarget = true)
    WidgetRenderer->DrawWidget(DrawnWidgetRenderTarget,
        WidgetToRender->TakeWidget(),
        DrawSize,
        DeltaTime,
        false); // THIS PARAMETER IS EXTREMELY IMPORTANT, this is for if you want to immediately update the render target.
    // bDeferRenderTargetUpdate: Whether or not the update is deferred until the end of the frame when it is potentially less expensive to update the render target.
    
    // Flush any queued rendering commands to immediately have the GPU draw the widget and get the texture information filled out
    FlushRenderingCommands(); // This is ANOTHER way of forcing the GPU to update the render target.
    
    // HINT HINT ^^^
    // Deferred cleanup of the widget renderer to be deleted AFTER the render command queue has been flushed
    BeginCleanup(WidgetRenderer);
    return true;
}
```

Для рисования виджета в мировом пространстве используется описанный выше подход, но вместо `DrawWidget` используется непосредственно `DrawWindow`.

Для рисования виджета в пространстве экрана он добавит user widget во второй виджет игрового слоя, предназначенный только для работы с widget components под названием `FWorldWidgetScreenLayer`, который напрямую взаимодействует с `SWorldWidgetScreenLayer`.

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="dev-debug-tools"></a>

## 9.0 Инструменты разработки и отладки для UMG/Slate

У Unreal Engine инструменты разработки и отладки для UMG и Slate, которые помогают создавать UI и могут использоваться как в редакторе, так и в собранных developer-сборках (включая консольные).

<a name="debug-console-commands"></a>

### 9.1 Отладочные команды консоли

[Официальная документация по Console Slate Debugger](https://docs.unrealengine.com/latest/INT/console-slate-debugger-in-unreal-engine/) (также находится на [Странице внешних ссылок](EXTERNAL_LINKS.md)).

- Пожалуйста, обратитесь к разделу [Консольные команды Slate Console Debugger](#slate-console-debugger) для конкретных консольных команд Slate Debugger.
- `Slate.HitTestGridDebugging [0/1]`: Переключатель для отображения hit test grid фокуса UMG/Slate.
- `SlateDebugger.Invalidate.[Disable/Enable]`: Включает или отключает визуализатор отладчика инвалидации.
- Команды Save Zone:
    - `r.DebugSafeZone.TitleRatio 0.96`: Значение по умолчанию — `1.0`. Соотношение Save Zone, которое будет возвращено `FDisplayMetrics::GetDisplayMetrics` на платформах, не имеющих определенной безопасной зоны, в диапазоне от 0 до 1.
    - `r.DebugActionZone.ActionRatio 0.96`: Значение по умолчанию — `1.0`. Соотношение Action Zone, которое будет возвращено `FDisplayMetrics::GetDisplayMetrics` на платформах, не имеющих определенной безопасной зоны, в диапазоне от 0 до 1.
    - `r.DebugSafeZone.Mode [integer between 0 and 2]`
        - `0`: Не отображать наложение Save Zone.
        - `1`: Отобразить наложение Title Save Zone.
        - `2`: Отобразить наложение Action Save Zone.
- `Slate.ThrottleWhenMouseIsMoving [0/1]`: По умолчанию — `false`. Следует ли пытаться увеличить отзывчивость UI на основе движения курсора мыши.
    - `True`: Разрешить throttling на основе движения мыши.
- `Slate.TargetFrameRateForResponsiveness [integer]`: По умолчанию — `35` кадров в секунду. Требуемая минимальная устойчивая средняя частота кадров, при которой мы будем считать редактор отзывчивым для плавного взаимодействия с UI.
- `Slate.AllowSlateToSleep [0/1]`: должен ли Slate переходить в спящий режим, когда нет активных таймеров, а пользователь бездействует.
- `Slate.SleepBufferPostInput [float]`: По умолчанию `0.0`. Количество времени, которое должно пройти без каких-либо действий пользователя, прежде чем Slate будет переведен в спящий режим (при условии, что нет активных таймеров).
- `Slate.RequireFocusForGamepadInput [0/1]`: по умолчанию — `false`. Должен ли движок игнорировать ввод с геймпада, если приложение в данный момент не активно.
- `Slate.Transform.FullscreenMouseInput [0/1]`: Значение по умолчанию — `true`. Установите значение true, чтобы преобразовать ввод мыши для учета растяжения вьюпорта при полноэкранных разрешениях, изначально не поддерживаемых монитором.
- `Slate.EnableTooltips [0/1]`: Значение по умолчанию — `true`, если платформе нужны всплывающие подсказки (tooltips) UI, в противном случае — `false`. Разрешить ли всплывающим подсказкам вообще появляться.
- `Slate.TriggerInvalidate`: Запускает глобальную инвалидацию всех виджетов. Не работает в shipping-сборках.

<a name="widget-reflector"></a>

### 9.2 Widget Reflector

[Официальная документация по Widget Reflector](https://docs.unrealengine.com/latest/INT/using-the-slate-widget-reflector-in-unreal-engine/) (также находится на [Странице внешних ссылок](EXTERNAL_LINKS.md)).

> Чтобы открыть Widget Reflector, вы можете перейти к `Tools/Debug/Widget Reflector` или собрать Widget Reflector как отдельное приложение при использовании версии Unreal Engine из исходников.

Инструмент Widget Reflector предназначен для помощи разработчикам в оптимизации и отладке UI, который позволяет разработчикам отлаживать:

- Widget Hierarchy: Иерархия виджетов, отображающая родительские и дочерние элементы виджетов. Вы можете проверить следующие свойства при использовании иерархии виджетов:
    - Название виджета
    - Видимость на переднем плане (FG Visibility)
    - Фокус
    - Clipping
    - Источник: Расположение исходного кода виджета для простоты доступа.
    - Address: Чистый путь к виджету, который slate использует при расчете иерархии виджетов и деревьев.
- Widget Details: Сведения о виджете, такие как видимость, фокус и т. д. (все, что Slate Widget предоставляет как exposed свойство).
- События виджета:
    - Input
    - Focus
    - Navigation
    - Warnings
    - Mouse Capture
- Навигацию по виджетам и Hit Test Grid
- Инвалидацию
- Обновление виджета
- Отрисовку виджета
- Clipping
- Culling
- Кэширование

![Отладочный вид Navigation Grid](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/widget_reflector_example.png)

> Для отладки устройств, таких как консоли или телефоны, вы можете использовать подключаемый модуль Remote Session (официальное название Slate Remote) в движке, чтобы подключить отладчик к устройству для live-отладки Slate и UMG с помощью Widget Reflector.

<a name="slate-console-debugger"></a>

### 9.3 Slate Console Debugger

Slate Console Debugger — это список консольных команд, которые можно использовать для отладки различных частей Slate в целях отладки. Каждая консольная команда имеет префикс `SlateDebugger.`, при включении параметр сделает так, что его отладочная информация будет напечатана в Output Log.

Хорошая новость в том, что вы можете включить эти переключатели в Widget Reflector, поэтому вам не нужно вводить разные команды отладки. ![Widget Reflector Slate Переключатели Console Debugger](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/widget_reflector_console_debugger.png)

Ниже приведен список каждой консольной команды Slate Debugger:

- Slate Trace, расположенный в `SlateTrace.cpp`:
    - `SlateDebugger.bCaptureRootInvalidationCallstacks [0/1]`: Всякий раз, когда корневой виджет является причиной инвалидации, захватить стек вызовов для получения информации для Slate Insights (еще один инструмент отладки, который является частью Unreal Insights).
- Events, расположенный в `ConsoleSlateDebugger.cpp`:
    - `SlateDebugger.Event.Start` ИЛИ `SlateDebugger.Start`: Запускает отладчик для событий.
    - `SlateDebugger.Event.Stop` ИЛИ `SlateDebugger.Stop`: Останавливает отладчик для событий.
    - `SlateDebugger.Event.LogWarning`: Логгирует события Warning.
    - `SlateDebugger.Event.LogInputEvent`: Логгирует события Input.
    - `SlateDebugger.Event.LogFocusEvent`: Логгирует события Focus.
    - `SlateDebugger.Event.LogAttemptNavigationEvent`: Логгирует события Attempted Navigation.
    - `SlateDebugger.Event.LogExecuteNavigationEvent`: Логгирует события Executed Navigation.
    - `SlateDebugger.Event.LogCaptureStateChangeEvent`: Логгирует события Input Capture State Change.
    - `SlateDebugger.Event.LogCursorChangeEvent`: Логгирует события изменения курсора.
    - `SlateDebugger.Event.CaptureStack`: Включает захват и логгирование стека вызовов при возникновении события.
    - `SlateDebugger.Event.InputRoutingModeEnabled`: Включает запись в лог маршрута, по которому прошло событие ввода.
    - `SlateDebugger.Event.SetInputFilter [Filter]`: Переключает определенные фильтры ввода:
        - Фильтры:
            - `MouseMove`
            - `MouseEnter`
            - `MouseLeave`
            - `PreviewMouseButtonDown`
            - `MouseButtonDown`
            - `MouseButtonUp`
            - `MouseButtonDoubleClick`
            - `MouseWheel`
            - `TouchStart`
            - `TouchEnd`
            - `TouchForceChanged`
            - `TouchFirstMove`
            - `TouchMoved`
            - `DragDetected`
            - `DragEnter`
            - `DragLeave`
            - `DragOver`
            - `DragDrop`
            - `DropMessage`
            - `PreviewKeyDown`
            - `KeyDown`
            - `KeyUp`
            - `KeyChar`
            - `AnalogInput`
            - `TouchGesture`
            - `MotionDetected`
    - `SlateDebugger.Event.DisableAllInputFilters`: Отключает все включенные фильтры ввода.
    - `SlateDebugger.Event.EnableAllInputFilters`: Включает все фильтры ввода.
    - `SlateDebugger.Event.SetFocusFilter [Filter]`: Переключает определенные фильтры фокуса:
        - Фильтры:
            - `FocusChanging`
            - `FocusLost`
            - `FocusReceived`
    - `SlateDebugger.Event.ClearFocusFilters`: Отключает все включенные фильтры фокуса.
    - `SlateDebugger.Event.EnableAllFocusFilters`: Включает все фильтры фокуса.
- Breaks(остановы), полезны для использования другими инструментами и требуют, чтобы отладчик был подключен к редактору, чтобы работать как точка останова(break point). Находится в `ConsoleSlateDebuggerBreak.cpp`:
    - `SlateDebugger.Break.OnWidgetInvalidation Reason=[Reason][WidgetPtr][WidgetId]`: Останов, когда введенный виджет становится невалидным.
        - Причины инвалидации:
            - `Layout`
            - `Paint`
            - `Volatility`
            - `ChildOrder`
            - `RenderTransform`
            - `Visibility`
            - `AttributeRegistration`
            - `Prepass`
            - `PaintAndVolatility`
            - `LayoutAndVolatility`
    - `SlateDebugger.Break.OnWidgetBeginPaint [WidgetPtr][WidgetId]`: Останов до того, как виджет начнет рисоваться.
    - `SlateDebugger.Break.OnWidgetEndPaint [WidgetPtr][WidgetId]` : Останов, когда виджет только-только был отрисован.
    - `SlateDebugger.Break.RemoveAll`: Удаляет все запросы на останов.
- Paint, расположенный в `ConsoleSlateDebuggerPaint.cpp`:
    - `SlateDebugger.Paint.Start`: Запуск инструмента отладки отрисованных виджетов. Используйте для отображения виджетов, которые были отрисованы в этом кадре.
    - `SlateDebugger.Paint.Stop`: Останавливает инструмент отладки отрисованных виджетов.
    - `SlateDebugger.Paint.Enable`: Переключает (Start/Stop) инструмент отладки отрисованных, чтобы показать виджеты, которые были отрисованы.
    - `SlateDebugger.Paint.LogOnce`: Логгирует в тулзе имена всех виджетов, которые были отрисованы во время последнего обновления.
    - `SlateDebugger.Paint.MaxNumberOfWidgetDisplayedInList [MaxNumberOfWidgetsInList]`: Максимальное количество виджетов, которые будут отображаться, когда в тулзе активен DisplayWidgetNameList.
    - `SlateDebugger.Paint.ToggleWidgetNameList`: Переключаемый параметр для отображения в тулзе имен виджетов, которые были отрисованы.
    - `SlateDebugger.Paint.LogWarningIfWidgetIsPaintedMoreThanOnce`: Включает в тулзе логгирование предупреждения, если виджет рисуется более одного раза в одном кадре.
    - `SlateDebugger.Paint.OnlyGameWindow`: Включает в тулзе только отладку виджетов игрового окна.
- Update, расположенный в `ConsoleSlateDebuggerUpdate.cpp` :
    - `SlateDebugger.Update.Start`: Запустить инструмент отладки обновлений виджета, чтобы показать, когда виджеты обновляются.
    - `SlateDebugger.Update.Stop`: Остановить инструмент отладки обновлений виджета.
    - `SlateDebugger.Update.Enable`: Переключить (Start/Stop) инструмент отладки обновления виджета, чтобы показать, когда виджеты обновляются.
    - `SlateDebugger.Update.ToggleLegend`: Включите отображение цветовой легенды (color legend) в инструменте.
    - `SlateDebugger.Update.ToggleWidgetNameList`: Включить отображение в инструменте имён виджетов, которые были обновлены.
    - `SlateDebugger.Update.ToggleUpdateFromPaint`: Включить, чтобы также отображались виджеты, которые не имеют флага обновления, но обновляются по цепной реакции с другим виджетом.
    - `SlateDebugger.Update.SetWidgetUpdateFlagsFilter`: Включить/отключить определенные фильтры флагов обновления виджета.
        - Фильтры, расположенные в `WidgetUpdateFlags.h`:
            - `None`
            - `Tick`: У виджета есть функция tick.
            - `ActiveTimer`: У виджета есть активный таймер, который необходимо обновить.
            - `Repaint`: Необходимо перерисовать виджет, потому что он dirty.
            - `VolatilePaint`: Необходимо перерисовать виджет, потому что он volatile.
            - `Any`
        - `SlateDebugger.Update.SetInvalidationRootIdFilter`: Включить отображение только тех виджетов, которые являются частью invalidation root.
        - `SlateDebugger.Update.OnlyGameWindow`: Включить отображение отладочной информации только для окна игры.
- Invalidation, расположенный в `ConsoleSlateDebuggerInvalidate.cpp`:
    - `SlateDebugger.InvalidationRoot.Start`: Запустить средство отладки инвалидации виджета. Он показывает виджеты, которые инвалидированы.
    - `SlateDebugger.InvalidationRoot.Stop`: Остановить инструмент отладки инвалидации виджета.
    - `SlateDebugger.InvalidationRoot.Enabled`: Переключить (Start/Stop) инструмент отладки инвалидации виджета для отображения невалидных виджетов.
    - `SlateDebugger.InvalidationRoot.bShowLegend`: Включить отображение цветовой легенды (color legend).
    - `SlateDebugger.InvalidationRoot.bShowWidgetList`: Переключить отображение имен инвалидируемых виджетов.
    - `SlateDebugger.InvalidationRoot.bLogInvalidatedWidget`: Включить логгирование в консоль невалидного виджета.
    - `SlateDebugger.InvalidationRoot.ThresholdPerformanceMS`: Для `bUsePerformanceThreshold` пороговое значение в миллисекундах, которое должно быть достигнуто перед логгированием и/или отображением невалидных виджетов.
    - `SlateDebugger.InvalidationRoot.bUsePerformanceThreshold`: Отобразить невалидные виджеты и/или логгировать их только в том случае, если производительность ниже порогового значения в миллисекундах.
    - `SlateDebugger.InvalidationRoot.SetInvalidateRootReasonFilter`: Включить/Выключить определенные фильтры причин инвалидации корневого виджета.
        - Фильтры, расположенные в `SlateDebugging.h`:
            - `None`
            - `ChildOrder`
            - `Root`
            - `ScreenPosition`
- InvalidationRoot, расположенный в `ConsoleSlateDebuggerInvalidationRoot.cpp`:
    - `SlateDebugger.InvalidationRoot.Start`: Запустить средство отладки инвалидации корневого виджета. Он показывает, когда invalidation roots используют медленный или быстрый путь.
    - `SlateDebugger.InvalidationRoot.Stop`: Остановить средство отладки инвалидации корневого виджета.
    - `SlateDebugger.InvalidationRoot.Enable`: Переключить (Start/Stop) инструмент отладки инвалидации корневого виджета, чтобы показать, когда invalidation roots используют медленный или быстрый путь.
    - `SlateDebugger.InvalidationRoot.ToggleLegend`: Переключить для отображения цветовой легенды (color legend).
    - `SlateDebugger.InvalidationRoot.ToggleWidgetNameList`: Включить отображение имени invalidation root.

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="input-framework-of-unreal-engine"></a>

## 10.0 Input Framework в Unreal Engine (то, что связано с UMG/Slate)

<a name="input-flow-of-unreal-engine"></a>

### 10.1 Поток ввода (Input Flow) Unreal Engine

Это высокоуровневый обзор потока ввода от самого низкого уровня до самого высокого уровня, который приведен ниже в порядке маршрутизации ввода для каждого пользователя (каждый этап вызывает следующий этап потока ввода Unreal Engine):

1. **Engine Heartbeat Tick** `FEngineLoop`: Heartbeat Tick Unreal Engine, который уведомляет SDK платформы о необходимости тикать/обновлять каждый кадр.
2. **Platform's API**`GenericApplication` &amp; `FGenericApplicationMessageHandler`: SDK для Windows/Mac/Xbox/Playstation/etc, который создает Slate Application при инициализации движка и посылает ему входные данные каждый кадр для каждого пользователя.
3. **Slate Application** `FSlateApplication`: Обрабатывает перенаправление ввода между Input Processors, Slate UI и игровым движком, чтобы код игры получал этот ввод.
4. **Input Processors** *необязательные* `IInputProcessor`: Это объекты C++, которые можно динамически добавлять/удалять из списка Input Pre Processors в Slate Applications и получать ввод раньше, чем что-либо еще, и контролируют, ввод используется или продолжат двигаться вниз по иерархии. Рекомендуется сделать свой кастомный для своего проекта, потому что он дает вам полный контроль над вашим вводом до того, как его получит что-либо еще в движке, в движке даже есть пример, сделанный Epic, под названием **AnalogCursor**! Он также будет получать ввод, даже если вы используете только Input Mode UI Onlu и получаете ввод в редакторе!
5. **Slate UI Elements** `SWidget`: Любые находящиеся в фокусе элементы UI на экране, которые должны получать ввод и могут использовать этот ввод.
    - Это также место, где **UMG Widgets** `UWidget` будут получать входные данные, поскольку UMG Widgets — это всего лишь оболочки на основе UObject для Slate Widgets.
6. **Game Viewport Client** `UGameViewportClient`: При просмотре кода может быть тяжело выяснить, где ввод направляется в Game Viewport Client, но в основном на уровне ядра, если Slate Application отправило его элементам Slate, а он не использовался, то он направляется вниз к виджету вьюпорта, который является Slate Widget (который также является визуальным представлением финально отрендеренного изображения игры), который затем направляется к Game Viewport Client, который обрабатывает распространение этого ввода на остальную часть игрового движка и связывает его с игровым кодом. Это тот момент, когда в зависимости от того, какой Штзге Mode вы используете, Input Mode Game/Input Mode Game and UI позволяют Pawns получать ввод.
7. **Контроллер игрока** `APlayerController`: Как только Game Viewport получает ввод, он должен пройти некоторые проверки, чтобы убедиться, что его можно использовать для игрового кода, а затем сообщает Player Controller добавить его в свой **Input Stack** внутри `ProcessPlayerInput`, который вызывается из `Tick` от Player Controller.
8. **Ввод игрока** `UPlayerInput`: Объект ввода игрока, который есть у Player Controllers для маршрутизации ввода к Pawns и другим объектам, которые находятся в его Input Stack.
9. **Input Component** `UInputComponent`: Это широко используемый метод получения ввода для игрового кода, который также можно найти в официальной документации Epic, это объект, который есть в каждом Actor, который связывается с Input Stack от Player Controller для получения ввода, который направляется через движок, чтобы игровой код его слушал и получал ввод.

![Схема потока ввода (Input Flow)](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/input_flow_diagram.png)<br> *Схема потока ввода (Input Flow)*

<a name="input-components"></a>

### 10.2 Input Components

Input Components — это `UActorComponent`, которые присутствуют во всех акторах (`AActor`). Эти компоненты будут связаны с AxisMappings и ActionMappings как привязки (bindings) в вашем проекте для работы функционала. Каждая привязка может потреблять события ввода (input events), что не позволяет другим компонентам входного стека обрабатывать то же самое входное событие. Input Components позволяют актору привязывать входные события к делегированным (delegate) функциям, которые автоматически обрабатываются двумя классами:

> - `APlayerController`:: Управляет построением Input Stack и управляет порядком и приоритетами.
> - `UPlayerInput`:: Обрабатывает broadcasting этих delegate функций и определяет, используется ли binding или нет.
>
> Вот фактический порядок операций для input components в каждом кадре. *Диаграмма ниже*
>
> 1. [`APlayerController::TickPlayerInput`]
>     1. [`UPlayerInput::Tick`]
>     2. Собирает события mouse over.
>     3. Собирает события touch over.
>     4. [`APlayerController::ProcessPlayerInput`]
>         1. [`APlayerController::BuildInputStack`]: Создает стек Input Components и порядок их обработки. Может быть переопределен для управления порядком.
>         2. [`UPlayerInput::ProcessInputStack`]: На самом деле начитает обрабатывать ввод.
>             1. [`APlayerController::PreProcessInput`]
>             2. Копирует состояние клавиш, не относящихся к осевым (axis keys).
>                 1. Начинает перебирать стек Input Components сверху вниз; один за другим (представьте, что мы работаем с одним Input Component, но в цикле, пока не закончатся Input Components).
>                     1. Создает раскладку клавиш для этого компонента ввода, чтобы знать, какие actions/axis работают с определенными привязками клавиш для создания связок ввода (input cords).
>                     2. Ищет touch bindings и решает, произошла ли привязка input action. Если это так, то отследить его.
>                     3. Ищет gesture bindings и решает, произошла ли привязка input action. Если это так, то отследить его.
>                     4. Ищет axis bindings и решает, произошла ли привязка input axis. Если это так, то отследить его.
>                     5. Решает, реагировать ли на клавишу или нет (на основе учета, сделанного между построением раскладки и достижением этой точки).
>             3. Сбрасывает axis bindings каждого input component к нулю.
>             4. Делает broadcast Input Actions к Input Components, которые должны запускать функционал.
>             5. Делает broadcast Input Axis к Input Components, которые должны запускать функционал.
>             6. [`APlayerController::PostProcessInput`]
>             7. [`UPlayerInput::FinishProcessingPlayerInput`]: Завершает обработку ввода для этого кадра, сохраняя состояния вводов, которые сейчас удерживаются (held). Очищает значения для следующего кадра.
>             8. Очищает все привязки, которые были переданы в broadcast.
>         3. Сбрасывает Input Stack для следующего кадра.
>     5. [`APlayerController::ProcessForceFeedbackAndHaptics`]

![Порядок операций входного компонента](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/input_component_order_operations.png) <br> *Порядок операций для того, как Input отмечается и обрабатывается на уровнях, начиная с `TickPlayerInput` внутри `APlayerController`*

У Input Components также может быть стек приоритетов, чтобы входные данные могли потребляться акторами с более высоким приоритетом.<br> Стек приоритетов для Input Components выглядит следующим образом (сначала наивысший приоритет):

1. Акторы с включенным параметром "Accepts Input", от недавно включенных до наименее недавно включенных.
    1. Чтобы переместить актора на вершину приоритета в этом стеке, вы можете повторно включить его значение "Accepts Input", и он будет перемещен на вершину стека приоритетов.
2. Player Controllers
3. Логика уровня
4. Pawns

![Стек Input Components](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/input_component_stack.png)<br> *Стек Input Components, любезно предоставленный [документацией Epic](https://docs.unrealengine.com/5.0/en-US/input/)*

<a name="input-event-types"></a>

### 10.3 Типы Input Event

Каждый раз, когда происходит ввод, для каждого типа ввода используется структура, которая наследуется от **FInputEvent**:

- **FInputEvent**: базовая структура для всех событий мыши, клавиш, событий Touch/Motion.
    - **Modifier Keys** `FModiferKeysState`: Состояние клавиш-модификаторов в момент, когда это событие произошло в течение этого кадра.
    - **Is Repeat** `bool`: Переключатель, определяющий, было ли это событие ввода автоматически повторено (удержано (held), а затем повторно сработало (fired)).
    - **User Index** `uint32`: Целочисленный индекс **Slate User**, вызвавшего это событие.
    - **Event Path** `const FWidgetPath*`: Путь к событиям, отправляемым вместе с этим событием.

Любой другой тип события исходит от `FInputEvent`:

- **FKeyEvent** `FInputEvent`: Key Action для клавиатуры/геймпада в состоянии нажатия/отпускания. Он передается обработчикам событий, имеющим дело с вводом этой клавиши.
    - **Key** `FKey`: Имя нажатой клавиши.
    - **CharacterCode** `uint32`: Код символа, что есть Unreal-friendly версия нажатой клавиши. Если не учитывается, код символа возвращает ноль.
    - **KeyCode** `uint32`: Изначальный код символа, полученный от железа/SDK.
- **FAnalogInputEvent** `FKeyEvent`: Описывает аналоговое значение ключа, чтобы учитывать стики.
    - **AnalogValue** `float`: Значение 0-1, обозначающее ось джойстика, 0 = не нажато и 1 = полностью нажато.
- **FCharacterEvent** `FInputEvent`: Действие клавиатуры, при котором вводится код UTF-16 (16-битная кодировка Unicode), используемый для функций OnKeyChar.
    - **Character** `TCHAR`: Символ, который был нажат.
- **FPointerEvent** `FInputEvent`: Ввод с помощью мыши/касания (поскольку касание также считается вводом с помощью мыши, просто использует только левую кнопку мыши в качестве ввода касания), используемый для нажатия/отжатия/перемещения/и т. д. Некоторые из этих значений вам, возможно, даже не понадобятся, но они предоставляют много полезной информации.
    - **ScreenSpacePosition** `FVector2D`: Текущая позиция этого события указателя в пространстве экрана.
    - **LastScreenSpacePosition** `FVector2D`: Позиция на экране этого события указателя для последнего кадра.
    - **CursorDelta** `FVector2D`: Расстояние между текущей и последней позициями на экране.
    - **PressedButtons** `const TSet<FKey>*`: Нажатые в данный момент кнопки мыши, которые использует это событие указателя.
    - **EffectingButton** `FKey`: Кнопка мыши, которую представляет это событие указателя (события касания всегда будут использовать левую кнопку мыши).
    - **PointerIndex** `uint32`: Какой индекс указателя (пальца) предназначен для этого Slate User.
    - **TouchpadIndex** `uint32`: Какой индекс указателя (пальца) предназначен для этого Slate User на ноутбуках с тачпадом.
    - **Принудительное** `float`: Какое усилие прикладывается к этому входу сенсорной панели/указателя.
    - **IsTouchEvent** `bool`: Является ли это событием указателя на основе касания (включая трекпад) или на основе мыши.
    - **GestureType** `EGestureType`: Какой тип жеста использует это событие указателя, например, свайп, прокрутка, увеличение, поворот, долгое нажатие и т. д.
    - **WheelOrGestureDelta** `FVector2D`: Разница в значении жеста с момента последнего события жеста того же типа.
    - **IsDirectionInvertedFromDevice** `bool`: Инвертирована ли разность значения жеста.
    - **IsTouchForceChanged** `bool`: Является ли это событие особым событием касания, когда меняется сила нажатия.
    - **IsTouchFirstMove** `bool`: Является ли это событие особым событием касания, когда палец впервые перемещается.
- **FMotionEvent** `FInputEvent`: Описывает событие тачпада с использованием внутреннего гироскопа, например нажатие/перемещение/изменение высоты/вращение/и т. д.
    - **Tilt** `FVector`: Текущий наклон устройства/контроллера.
    - **RotationRate** `FVector`: Скорость вращения устройства/контроллера.
    - **Gravity** `FVector`: Направление силы тяжести в реальном мире (направленное вниз к земле), о котором сообщило устройство/контроллер.
    - **Acceleration** `FVector`: 3D-ускорение устройства/контроллера.
- **FNavigationEvent** `FInputEvent`: Cобытие focus navigation для Left/Right/Up/Down, которое передается для **User Focus**.
    - **NavigationType** `EUINavigation`: Направление навигации для этого события, если оно было вверх/вниз/влево/вправо/и т. д.
    - **NavigationGenesis** `ENavigationGenesis`: Перечисление для определения того, откуда пришло (было вызвано) это навигационное событие, например, клавиатура/контроллер/User.

<a name="input-modes"></a>

### 10.4 Input Modes

В **WidgetBlueprintLibrary** есть 3 функции для выбора так называемого режима ввода или **Input Mode** в Player Controllers, три состояния объясняют, что на самом деле происходит во входном потоке по отношению к шагу 6; Game Viewport Client. Важно понимать, что специального Input Mode нет, но есть ярлыки для изменения значений в Game Viewport Client через Player Controller.

Любые изменения, сделанные для ввода значений режимов, будут сохраняться между путешествиями по уровню/карте, независимо от того, использовали ли вы для их изменения стандартные функции Unreal Engine или изменили эти значения вручную в Game Viewport Client.

- **Input Mode UI Only**: В основном говорит Game Viewport Client игнорировать ввод, поэтому любой ввод, который получает Game Viewport Client, отбрасываются, поэтому ввод не направляется на более поздние шаги в потоке ввода И отпускает мышь, чтобы вы могли кликать во вьюпорте (или за пределами вьюпорта, если это разрешает **Mouse Lock Mode**).
- **Input Mode Game Only**: Сообщает Game Viewport Client, что он может получать ввод, поэтому, когда Game Viewport Client получает этот ввод, он должным образом перенаправляются на более поздние этапы потока ввода, и блокирует мышь, чтобы нельзя было кликать во вьюпорте.
- **Input Mode Game &amp; UI**: Сообщает Game Viewport Client, что он может получать ввод И отпускает мышь, чтобы вы могли кликать во вьюпорте (или за пределами вьюпорта, если это разрешает **Mouse Lock Mode**).

[](https://youtu.be/ktIDz1wCe0Y)![Input Modes Video Example](https://github.com/YawLighthouse/UMG-Slate-Compendium/blob/main/video_thumbnails/input_modes_video_thumbnail.png?raw=true)

Mouse Lock Mode `EMouseLockMode` — это то, как курсор мыши блокируется (значит, курсор не может выйти за границы) во вьюпорте в зависимости от режима, в котором он находится:

- **Do Not Lock**: Не блокировать курсор мыши во вьюпорте.
- **Lock On Capture**: Блокировка курсора мыши в окне просмотра только при захвате мыши (щелчок или взаимодействие с вьюпортом).
- **Lock Always**: Всегда блокировать курсор мыши во вьюпорте, не позволяя ему покидать вьюпорт.
- **Lock in Fullscreen**: Всегда блокировать курсор, если это полноэкранный режим.

> Я хочу указать, что режим блокировки мыши предназначен для каждого вьюпорта, что считается в split screen для вьюпорта каждого игрока, в то время как окно будет учитывать целое окно из всех вьюпортов.

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="unreals-focusing-system"></a>

## 11.0 Система фокусировки Unreal

Система фокусировки Unreal Engine в контексте Slate/UMG — это концепция фокуса пользователя или **User Focus**, при которой только один **Slate Widget** может быть сфокусирован одновременно конкретным пользователем, известным как **Slate User** .

Несколько Slate Users могут фокусироваться на одном и том же виджете, но пользователь не может фокусироваться на двух виджетах одновременно (для этого вам потребуется создать эту функциональность самостоятельно, но в этот момент вы, вероятно, боретесь с ней, а не работаете с ней и экономите время на управлении обоими виджетами игры, создавая свою пользовательскую систему фокусировки).

Фокус пользователя отслеживается приложением **Slate Application** с помощью целочисленного индекса для каждого **пользователя Slate User** и пути фокуса виджета **Slate Widget**, на котором пользователь фокусируется в данный момент, это локальные пользователи в этом приложении для учета игроков с разделенным экраном. Фокус будет сохраняться между перемещениями по уровню/карте, поэтому хорошей практикой является его сброс путем отправки фокуса обратно в область просмотра игры.

Система фокусировки Unreal Engine состоит из 4 ключевых элементов:

- **Slate Application**: Занимается отслеживанием того, какой виджет в данный момент находится в фокусе (включая уведомление об изменении фокуса) и сообщает системе фокусировки, что ввод был нажат.
- **HittestGrid** (да, именно так назван класс, думаю, тут опечатка в HitTestGrid): Занимается поиском следующего фокусируемого виджета с помощью функции FindNextFocusableWidget и возвращает его в Slate Application.
- **SWidget**: Это базовая функциональность во всех виджетах, которая должна быть переопределена:
    - `OnKeyDown`: Когда клавиша нажата и фокус находится на этом виджете, это функция, которую виджет должен делать.
    - `OnNavigation`: Когда виджет находится в фокусе/теряет фокус и т. д.
- **Navigation Config**: Определяет, какое направление навигации использовать на основе ввода.

<a name="navigation-grid-explanation"></a>

### 11.1 Объяснение навигационной сетки (Navigation Grid)

> Чтобы визуализировать сетку проверки попадания, используйте консольную команду `Slate.HitTestGridDebugging [0/1]`, которая также находится в подразделе [Отладочные команды консоли](#debug-console-commands) раздела [Инструменты разработки и отладки для UMG/Slate](#dev-debug-tools).

Сетка проверки попадания (hit test grid) — это по сути то, как обрабатывается навигация, а это способствует тому, к какому виджету переходить для каждого использования (поэтому у каждого пользователя есть своя собственная hit test grid), навигация рассчитывается только в направлении, указанном вдоль сетки (при разрешении 128, и его нет причин менять, поскольку проверяется, находится ли виджет в пределах этой равномерно распределенной сетки по прямой линии), состоящей из сталкивающихся ограничивающих рамок (bounding boxes) каждого выбранного виджета (таким образом, здесь вступают в игру desired size и геометрия), а эта сетка заполняется на основе конкретных виджетов, которые выбрали эту hit test grid.

![Первый пример Hit Test Grid](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/hittest_grid_1.png) | ![Пример Hit Test Grid 2](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/hittest_grid_2.png)
:-: | :-:


*В этом примере мы показываем, к каким кнопкам мы можем перейти при нажатии направления навигации. Кнопка Button 2 в этом случае всегда будет переходить к ближайшему виджету, потому что она может перейти к любому нижестоящему виджету.*

![Отладочный вид Navigation Grid](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/nav_grid_debug.png)<br> *Вот как на самом деле выглядит Navigation Grid в примере при использовании консольной команды `Slate.HitTestGridDebugging 1`.*

Когда происходит **Navigation Genesis**, по сути получаются ячейки, в которых находится текущий focused виджет, а затем, основываясь на направлении навигации, hit test делает проверку по прямой линии, чтобы найти фокусируемый виджет, просматривая каждую ячейку, чтобы увидеть, есть ли bounding box виджета внутри неё и запуская серию серии проверок в указанном порядке, если они не проходят эти проверки, мы возвращаем для неё результат отладки и пропускаем её:

1. **Does Not Interest**: Если bounding прямоугольник виджета не пересекается с разверткой.
2. **Previous Widget Is Better**: Если виджет не ближе, чем ранее проверенный виджет, значит, проверка неудачна, потому что предыдущий виджет был ближе, предпочтение всегда отдается ближайшему виджету.
3. **Not A Descendent**: Если boundary navigation rule виджета не Escape, и виджет не является потомком нашего виджета с граничными условиями (поэтому мы не должны переходить к этому виджету в первую очередь).
4. **Disabled**: Если этот виджет не включен.
5. **Does Not Support Keyboard Focus**: Этот виджет не поддерживает фокус с клавиатуры.

После того, как виджет прошел эти тесты, он сохраняется как лучший виджет и сохраняет свой **Slate Rect** (для последующего использования для навигации), а делается проверка, что там за boundary navigation rule виджета (Explicit, Custom, CustomBoundary, Stop, Wrap) и работает с каждым, который не Escape. Как только развертка достигает края окна экрана, фокус перенаправляется на лучший виджет.

Вы также можете узнать, когда фокус изменяется для любого пользователя (обязательно отфильтруйте для конкретных пользователей!), получив Slate Application и получив его `FocusChangingDelegate` с помощью функции `OnFocusChanging()` (в зависимости от вашей версии Unreal вы можете просто получить саму delegate переменную) и прослушивая изменения фокуса.

Вы можете отфильтровать, какой пользователь изменил фокус с помощью `FFocusEvent`, у которого delegate выдаёт, есть ли у него индекс игрока, у которого сменился фокус (также есть причина для изменения фокуса, если вам нужно знать это для конкретного варианта использования).

*Прокрутите вправо до заголовочного файла -&gt;*


<table> <tr> <td style="text-align: center;">Файл кода (.cpp)</td>  <td style="text-align: center;">Файл заголовка (.h)</td> </tr> <comment data-md-type="comment"></comment> <td> ```c++ void AMyPlayerController::BeginPlay() {   Super::BeginPlay();  <p data-md-type="paragraph">// Valid check that slate application initialized if(FSlateApplication::IsInitialized()) { // Depending on your version of Unreal Engine, // you may need to just do "FSlateApplication::Get().FocusChangingDelegate" instead of using a function to get it</p> <pre data-md-type="block_code" data-md-language="">// Bind for when focus changes, if you're having issues with this then I recommend learning about Unreal's delegate framework
// or looking at the slate application's header and source file regarding the focus changing delegate
FSlateApplication::Get().OnFocusChanging().AddUObject(this, &amp;AMyPlayerController::FocusChanged);
</pre> <p data-md-type="paragraph">}<br> }</p> <p data-md-type="paragraph">void AMyPlayerController::FocusChanged(const FFocusEvent&amp; FocusEvent, const FWeakWidgetPath&amp; OldFocusedWidgetPath, const TSharedPtr<swidget data-md-type="raw_html">&amp; OldFocusedWidget, const FWidgetPath&amp; NewFocusedWidgetPath, const TSharedPtr<swidget data-md-type="raw_html">&amp; NewFocusedWidget) { // Check if this player controller has a valid local player object yet if(!IsValid(GetLocalPlayer())) { // If we don't have a valid local player object then don't continue because we're not done setting up the player controller return; } // Check if the player that changed focus is ourselves if(GetLocalPlayer()-&gt;GetControllerId() != FocusEvent.GetUser()) { // If self didn't do this focus change, then don't continue return; } // Do stuff }</swidget></swidget></p> <pre data-md-type="block_code" data-md-language="">&lt;/td&gt;
&lt;td&gt;
```c++
UCLASS()
class MYGAME_API AMyPlayerController : public APlayerController
{
	GENERATED_BODY()
protected:
  // AActor interface
  virtual void BeginPlay() override;
  // ~AActor interface
  /**
   * Occurs when a Slate User changes widget focus.
   * @param FocusEvent The type of focus event that occured.
   * @param OldFocusedWidgetPath The previously focused widget's path in the widget tree.
   * @param OldFocusedWidget The previously focused slate widget.
   * @param NewFocusedWidgetPath The widget path of the slate widget we're going to focus.
   * @param NewFocusedWidget The slate widget we're going to focus.
   */
  virtual void FocusChanged(const FFocusEvent&amp; FocusEvent,
    const FWeakWidgetPath&amp;  OldFocusedWidgetPath,
    const TSharedPtr&lt;SWidget&gt;&amp; OldFocusedWidget,
    const FWidgetPath&amp; NewFocusedWidgetPath,
    const TSharedPtr&lt;SWidget&gt;&amp; NewFocusedWidget);
};
</pre> </td> <div data-md-type="block_html"></div> </table>

<a name="navigation-genesis"></a>

### 11.2 Navigation Genesis

Навигация может быть вызвана тремя типами, известными как **Navigation Genesis**:

- **Keyboard**: Событие навигации было вызвано вводом с клавиатуры.
- **Контроллер**: Событие навигации было вызвано вводом с геймпада.
- **Пользователь**: событие навигации — это событие, сгенерированное пользователем, которое было вызвано игровым кодом, виджетами и т. д.

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="split-screen"></a>

## 12.0 Split Screen

Split Screen работает, когда у него есть **Game Layer Manager**, который управляет slate widget вьюпорта, тем, какой игрок использует этот slate widget и как формировать этот slate widget. Game layer manager инстансируется игровым движком при инициализации внутри `GameEngine.cpp`(`UGameEngine`) и в `PlayLevel. cpp`(`UEditorEngine`) используется hard coded класс, поэтому для создания собственного потребуется модифицировать исходный код движка в `UGameEngine::CreateGameViewportWidget` &amp; `UEditorEngine:: GeneratePIEViewportWindow` (Epic, если вы видите это, пожалуйста, измените это на настраиваемый класс, который можно указать в настройках проекта, у вас он настроен для Game Viewport Client, а это уже половина пути!).

> Одним из возможных путей, в зависимости от вашего use case, может быть вызов `UGameViewportClient::SetGameLayerManager`, но имейте в виду, что это может иметь последующие эффекты и может потребовать некоторых обходных путей из непереключаемого кода движка.

При выводе виджета на экран у вас есть два варианта:

- **Add to Viewport**: Добавляет во вьюпорт целиком, закрывая вьюпорт обоих игроков этим одним виджетом; полезно для меню паузы или чего-либо, что должно полностью занимать экран и должно влиять на всех других локальных игроков.
- **Add to Player Screen**: Добавляет во вьюпорт этого конкретного игрока и не закрывает вьюпорты других игроков этим одним виджетом; полезно для HUD или всего, что характерно для этого локального игрока, но не для всех остальных игроков.

<a name="game-layer-manager"></a>

### 12.1 Game Layer Manager

Game Layer Manager - это интерфейс, который содержит основную информацию для получения геометрии вьюпорта, получения локального игрока, использующего этот виджет, добавления слоев виджетов (не рекомендуется, если вы не знаете, что делаете), который содержит все slate widgets, добавленные в данный конкретный вьюпорт, и для хранения собственно slate widget игрового вьюпорта. Менеджер игрового слоя находится в `SGameLayerManager.h/cpp` и содержит интерфейс (`IGameLayerManager`) и составной виджет `SGameLayerManager`, который управляет отображением виджета игрового вьюпорта (также полезен как базовый пример реализации интерфейса), используя простой макет прямоугольника, получаемый от клиента игрового вьюпорта. `SGameLayerManager` также направляет изменения масштаба DPI и для масштабирования области просмотра на основе значения масштаба DPI, включая все слои виджета.

<a name="viewport-layout"></a>

### 12.2 Viewport Layout

По умолчанию layout-дизайн представляет собой прямоугольник, который настраивается с помощью размера X/Y и положения X/Y на экране в соотношении 0-1 для его центра. Это устанавливается в `UGameViewportClient` по умолчанию. Если вы хотите создать свои собственные формы вьюпорта; вам нужно будет создать свой собственный класс Game Layer Manager, чтобы он вычислил пользовательскую форму и применил ее к виджету вьюпорта.

![Game Viewport Layer Framework](https://github.com/YawLighthouse/UMG-Slate-Compendium/raw/main/images/game_layer_general.png) <br> *Это общий обзор работы менеджера игровых слоев с некоторым визуальным объяснением того, как Slate Application взаимодействует с этими системами.*

<a name="local-players"></a>

### 12.3 Local Players

У каждого локального игрока на одном компьютере есть объект `ULocalPlayer`, который может существовать между уровнями. Это буквальное представление игрока как типа `UObject`, каждый локальный игрок полезен для того, чтобы узнать, какой геймпад использует этот игрок, какой viewport client использует этот игрок, получить своего Slate User, получить информацию об онлайн-подсистеме и т. д.

Локальные игроки отслеживаются с использованием разных идентификаторов для разных элементов приложения, они перечислены ниже:

- Platform ID: Идентификатор игрока на этом компьютере, поэтому индекс 0 будет начальным игроком.
- Controller ID: Здесь написано "контроллер", но на самом деле это идентификатор геймпада.
- Unique Net ID: Уникальный сетевой идентификатор для этого игрока на уровне в сетевом мультиплеере.

<a name="gamepad-id"></a>

#### 12.3.1 Gamepad ID (Controller ID)

> Gamepad ID на самом деле является Controller ID, но во избежание путаницы с этого момента мы будем упоминать Gamepad ID. Кроме того, ни одна из функций Gamepad ID недоступна в Blueprint, поэтому вам нужно будет реализовать это самостоятельно, но все они являются public значениями и функциями в `ULocalPlayer`.

Local Players могут узнать, какой Gamepad ID они используют, вызвав `ULocalPlayer::GetControllerId()`. Чтобы изменить его на другой геймпад, вы должны вызвать `ULocalPlayer::SetControllerId()`, если другой игрок использует этот идентификатор, тогда Gamepad ID принудительно поменяются местами, а ещё обновится Platform ID. Для получения delegates при изменении Gamepad ID вы можете использовать `ULocalPlayer::OnControllerIdChanged()`.

> Почему это Controller ID, а не Gamepad ID? Я, честно говоря, знаю, надеюсь, Epic исправит этот naming convention, потому что можно перепутать Player Controller, а не о геймпаде как контроллере (честно говоря, можно назвать это геймпадом и на 100% устранить путаницу). Комментарии к коду также чётко это не объясняют, потому что ссылаются на него как на физический ControllerID, который опять же можно спутать с Player Controller.

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
<a name="important-file-names"></a>

## 13.0 Имена важных файлов

Вот список (в произвольном порядке) важных/полезных файлов C++ в Unreal Engine, на которые рекомендуется обратить внимание, некоторые из них могут даже не упоминаться в этом сборнике.

Вам не нужно сразу понимать это, но это помогает узнать полезные файлы, к которым можно вернуться.

Имя объекта | Заголовок | Источник | Заметки
:-: | :-: | :-: | :--
`FEngineLoop`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Launch/FEngineLoop/) | LaunchEngineLoop.h | LaunchEngineLoop.cpp | Это сердце всего приложения Unreal Engine, рекомендую только смотреть, но не трогать.
[Несколько] | SharedPointer.h | SharedPointerInternals.h | Здесь находится Epic Shared(Smart) Pointer Framework, также рекомендуем взглянуть на `SharedPointerTesting.inl`, например, на использование общих указателей.
`FSlateApplication`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Slate/Framework/Application/FSlateApplication/) | SlateApplication.h | SlateApplication.cpp |
`FHittestGrid`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/SlateCore/Input/FHittestGrid/) | HittestGrid.h | HittestGrid.cpp |
`SWidget`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/SlateCore/Widgets/SWidget/) | SWidget.h | SWidget.cpp |
`UWidget`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/UMG/Components/UWidget/) | Widget.h | Widget.cpp |
[Несколько] | DeclarativeSyntaxSupport.h | [Нет] | Содержит все макросы декларативного синтаксиса для использования Slate, такие как SNew, SLATE_ARGUMENT и т.д. Чрезвычайно важный файл для изучения.
`SUserWidget`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/SlateCore/Widgets/SUserWidget/) | SUserWidget.h | SUserWidget.cpp |
`UUserWidget`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/UMG/Blueprint/UUserWidget/) | UserWidget.h | UserWidget.cpp |
`FNavigationConfig`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Slate/Framework/Application/FNavigationConfig/) | NavigationConfig.h | NavigationConfig.cpp | Здесь находится большинство типов, связанных с навигацией, включая структуры и перечисления.
[Несколько] | SlateEnums.h | [Нет] | Здесь находится большинство типов Enum, связанных с Slate.
`TAttribute`<br>[Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Core/Misc/TAttribute/) | Attribute.h | [Нет] |
`TSlateAttribute`<br>[Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/SlateCore/Widgets/TSlateAttribute_FText_EInvalidat-/) | SWidget.h и SlateAttribute.h |  | Хотя это объявлено в `SWidget.h`, на самом деле это объясняется в `SlateAttribute.h`
[Несколько] | InputCoreTypes.h | InputCoreTypes.cpp | Именно здесь находится большинство типов, связанных с вводом, включая структуры и перечисления.
`FInputEvent`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/SlateCore/Input/FInputEvent/) | Events.h | Events.cpp | Здесь находится иерархия типов `FInputEvent`.
`SGameLayerManager`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Slate/SGameLayerManager/) | SGameLayerManager.h | SGameLayerManager .cpp |
`UGameViewportClient`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Engine/UGameViewportClient/) | GameViewportClient.h | GameViewportClient.cpp |
[Несколько] | UnrealClient.h | UnrealClient.cpp | Этот интересен тем, что он одновременно содержит объекты-менеджеры для рендеринга окна просмотра и некоторые его функции.<br> Здесь же обрабатываются скриншоты (в том числе с/без пользовательского интерфейса).
`FSceneViewport`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Slate/FSceneViewport/) | SceneViewport.h | SceneViewport.cpp | Здесь, по сути, находится виджет планшета нашего видового экрана.
`IInputProcessor`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Slate/Framework/Application/IInputProcessor/) | IInputProcessor.h | [Нет] | Это базовый класс интерфейса для Input Preprocessors, от которого вы можете наследоваться, если будете создавать его. Для примера того, как его настроить, найдите FAnalogCursor.
`FAnalogCursor`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Slate/Framework/Application/FAnalogCursor/) | AnalogCursor.h | AnalogCursor.cpp |
`FSlateUser`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Slate/Framework/Application/FSlateUser/) | SlateUser.h | SlateUser.cpp |
`ULocalPlayer`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Engine/ULocalPlayer/) | LocalPlayer.h | LocalPlayer.cpp | Также содержит `FLocalPlayerContext`, который полезен для передачи пользовательскому интерфейсу и другим объектам, чтобы иметь контекст для локального игрока, его player controller, game instance, мира и т. д.
`UWidgetLayoutLibrary`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/UMG/Blueprint/UWidgetLayoutLibrary/) | WidgetLayoutLibrary.h | WidgetLayoutLibrary.cpp |
`USlateBlueprintLibrary`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/UMG/Blueprint/USlateBlueprintLibrary/) | SlateBlueprintLibrary.h | SlateBlueprintLibrary.cpp | На заметку, имя сценария также пишется как "SlateLibrary" на случай, если у вас возникнут проблемы с его поиском.
`UWidgetBlueprintLibrary`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/UMG/Blueprint/UWidgetBlueprintLibrary/) | WidgetBlueprintLibrary.h | WidgetBlueprintLibrary.cpp | На заметку, имя сценария также пишется как "WidgetLibrary" на случай, если у вас возникнут проблемы с его поиском.
`UUserinterfaceSettings`<br> [Документация](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Engine/UUserInterfaceSettings/) | Пользовательский интерфейсSettings.h | UserinterfaceSettings.cpp | Здесь также объявляется правило фокуса рендеринга и несколько других типов данных, которые вы найдете в этих настройках.

**[<span>⬆</span> Вернуться в начало](#table-of-contents)**
